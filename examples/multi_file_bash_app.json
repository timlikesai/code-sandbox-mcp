[
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "bash",
        "filename": "lib/utils.sh",
        "save": true,
        "session_id": "bash-monitor",
        "code": "#!/bin/bash\n# Utility functions library for system monitoring\n\n# Color codes for output\nreadonly COLOR_RED='\\033[0;31m'\nreadonly COLOR_GREEN='\\033[0;32m'\nreadonly COLOR_YELLOW='\\033[1;33m'\nreadonly COLOR_BLUE='\\033[0;34m'\nreadonly COLOR_RESET='\\033[0m'\n\n# Logging functions\nlog_info() {\n    echo -e \"${COLOR_BLUE}[INFO]${COLOR_RESET} $(date '+%Y-%m-%d %H:%M:%S') - $*\"\n}\n\nlog_success() {\n    echo -e \"${COLOR_GREEN}[SUCCESS]${COLOR_RESET} $(date '+%Y-%m-%d %H:%M:%S') - $*\"\n}\n\nlog_warning() {\n    echo -e \"${COLOR_YELLOW}[WARNING]${COLOR_RESET} $(date '+%Y-%m-%d %H:%M:%S') - $*\" >&2\n}\n\nlog_error() {\n    echo -e \"${COLOR_RED}[ERROR]${COLOR_RESET} $(date '+%Y-%m-%d %H:%M:%S') - $*\" >&2\n}\n\n# String manipulation functions\ntrim() {\n    local var=\"$*\"\n    # Remove leading whitespace\n    var=\"${var#\"${var%%[![:space:]]*}\"}\"\n    # Remove trailing whitespace\n    var=\"${var%\"${var##*[![:space:]]}\"}\"\n    echo -n \"$var\"\n}\n\nto_upper() {\n    echo \"$1\" | tr '[:lower:]' '[:upper:]'\n}\n\nto_lower() {\n    echo \"$1\" | tr '[:upper:]' '[:lower:]'\n}\n\n# Validation functions\nis_number() {\n    [[ \"$1\" =~ ^[0-9]+$ ]]\n}\n\nis_empty() {\n    [[ -z \"$(trim \"$1\")\" ]]\n}\n\n# File operations\nensure_directory() {\n    local dir=\"$1\"\n    if [[ ! -d \"$dir\" ]]; then\n        mkdir -p \"$dir\" || {\n            log_error \"Failed to create directory: $dir\"\n            return 1\n        }\n        log_info \"Created directory: $dir\"\n    fi\n}\n\nbackup_file() {\n    local file=\"$1\"\n    local backup=\"${file}.backup.$(date +%Y%m%d_%H%M%S)\"\n    \n    if [[ -f \"$file\" ]]; then\n        cp \"$file\" \"$backup\" || {\n            log_error \"Failed to backup file: $file\"\n            return 1\n        }\n        log_info \"Backed up file: $file -> $backup\"\n    fi\n}\n\n# Array utilities\njoin_array() {\n    local delimiter=\"$1\"\n    shift\n    local first=\"$1\"\n    shift\n    printf '%s' \"$first\" \"${@/#/$delimiter}\"\n}\n\n# Convert bytes to human readable format\nbytes_to_human() {\n    local bytes=\"$1\"\n    local units=(\"B\" \"KB\" \"MB\" \"GB\" \"TB\")\n    local unit=0\n    \n    while (( $(echo \"$bytes >= 1024\" | bc -l) )) && (( unit < ${#units[@]} - 1 )); do\n        bytes=$(echo \"scale=2; $bytes / 1024\" | bc)\n        ((unit++))\n    done\n    \n    printf \"%.2f %s\" \"$bytes\" \"${units[$unit]}\"\n}\n\n# Calculate percentage\ncalculate_percentage() {\n    local part=\"$1\"\n    local total=\"$2\"\n    \n    if (( $(echo \"$total == 0\" | bc -l) )); then\n        echo \"0.00\"\n    else\n        printf \"%.2f\" \"$(echo \"scale=2; ($part / $total) * 100\" | bc)\"\n    fi\n}\n\n# Error handling\nset_error_trap() {\n    trap 'log_error \"Error occurred in ${BASH_SOURCE[0]} at line ${LINENO}\"' ERR\n}\n\n# Cleanup function for trap\ncleanup_on_exit() {\n    local exit_code=$?\n    if [[ $exit_code -ne 0 ]]; then\n        log_error \"Script exited with code: $exit_code\"\n    fi\n    # Add any cleanup tasks here\n}\n\necho \"✓ lib/utils.sh validated and saved\""
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "bash",
        "filename": "config/settings.sh",
        "save": true,
        "session_id": "bash-monitor",
        "code": "#!/bin/bash\n# Configuration and constants for system monitoring\n\n# System thresholds\nreadonly CPU_WARNING_THRESHOLD=70\nreadonly CPU_CRITICAL_THRESHOLD=90\nreadonly MEMORY_WARNING_THRESHOLD=80\nreadonly MEMORY_CRITICAL_THRESHOLD=95\nreadonly DISK_WARNING_THRESHOLD=85\nreadonly DISK_CRITICAL_THRESHOLD=95\n\n# Monitoring intervals (in seconds)\nreadonly DEFAULT_INTERVAL=5\nreadonly MIN_INTERVAL=1\nreadonly MAX_INTERVAL=3600\n\n# Report settings\nreadonly REPORT_DIR=\"/tmp/system_monitor_reports\"\nreadonly REPORT_PREFIX=\"system_report\"\nreadonly MAX_REPORT_AGE_DAYS=7\n\n# Process monitoring settings\nreadonly TOP_PROCESSES_COUNT=10\nreadonly PROCESS_NAME_MAX_LENGTH=50\n\n# Network monitoring settings\nreadonly NETWORK_INTERFACES=(\"eth0\" \"lo\" \"wlan0\" \"docker0\")\nreadonly NETWORK_STATS_FIELDS=(\"rx_bytes\" \"tx_bytes\" \"rx_packets\" \"tx_packets\")\n\n# Declare associative arrays for service configurations\ndeclare -A SERVICE_PORTS=(\n    [\"ssh\"]=22\n    [\"http\"]=80\n    [\"https\"]=443\n    [\"mysql\"]=3306\n    [\"postgresql\"]=5432\n    [\"redis\"]=6379\n)\n\ndeclare -A SERVICE_NAMES=(\n    [22]=\"SSH\"\n    [80]=\"HTTP\"\n    [443]=\"HTTPS\"\n    [3306]=\"MySQL\"\n    [5432]=\"PostgreSQL\"\n    [6379]=\"Redis\"\n)\n\n# Alert configurations\ndeclare -A ALERT_LEVELS=(\n    [\"info\"]=0\n    [\"warning\"]=1\n    [\"critical\"]=2\n    [\"fatal\"]=3\n)\n\n# System paths\nreadonly PROC_STAT=\"/proc/stat\"\nreadonly PROC_MEMINFO=\"/proc/meminfo\"\nreadonly PROC_LOADAVG=\"/proc/loadavg\"\nreadonly PROC_NET_DEV=\"/proc/net/dev\"\nreadonly PROC_UPTIME=\"/proc/uptime\"\n\n# Output formats\nreadonly OUTPUT_FORMAT_JSON=\"json\"\nreadonly OUTPUT_FORMAT_TEXT=\"text\"\nreadonly OUTPUT_FORMAT_CSV=\"csv\"\nreadonly DEFAULT_OUTPUT_FORMAT=\"text\"\n\n# Feature flags\nreadonly ENABLE_CPU_MONITORING=true\nreadonly ENABLE_MEMORY_MONITORING=true\nreadonly ENABLE_DISK_MONITORING=true\nreadonly ENABLE_NETWORK_MONITORING=true\nreadonly ENABLE_PROCESS_MONITORING=true\nreadonly ENABLE_SERVICE_MONITORING=true\n\n# Export configuration validation function\nvalidate_config() {\n    local errors=0\n    \n    # Check if required directories exist or can be created\n    if ! mkdir -p \"$REPORT_DIR\" 2>/dev/null; then\n        echo \"ERROR: Cannot create report directory: $REPORT_DIR\" >&2\n        ((errors++))\n    fi\n    \n    # Validate thresholds\n    if (( CPU_WARNING_THRESHOLD >= CPU_CRITICAL_THRESHOLD )); then\n        echo \"ERROR: CPU warning threshold must be less than critical threshold\" >&2\n        ((errors++))\n    fi\n    \n    if (( MEMORY_WARNING_THRESHOLD >= MEMORY_CRITICAL_THRESHOLD )); then\n        echo \"ERROR: Memory warning threshold must be less than critical threshold\" >&2\n        ((errors++))\n    fi\n    \n    if (( DISK_WARNING_THRESHOLD >= DISK_CRITICAL_THRESHOLD )); then\n        echo \"ERROR: Disk warning threshold must be less than critical threshold\" >&2\n        ((errors++))\n    fi\n    \n    return $errors\n}\n\necho \"✓ config/settings.sh validated and saved\""
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "bash",
        "filename": "services/file_service.sh",
        "save": true,
        "session_id": "bash-monitor",
        "code": "#!/bin/bash\n# File service functions for report management\n\n# Source dependencies\nsource \"$(dirname \"${BASH_SOURCE[0]}\")/../lib/utils.sh\" 2>/dev/null || {\n    echo \"ERROR: Cannot source utils.sh\" >&2\n    exit 1\n}\n\nsource \"$(dirname \"${BASH_SOURCE[0]}\")/../config/settings.sh\" 2>/dev/null || {\n    echo \"ERROR: Cannot source settings.sh\" >&2\n    exit 1\n}\n\n# Generate report filename\ngenerate_report_filename() {\n    local format=\"${1:-$DEFAULT_OUTPUT_FORMAT}\"\n    local timestamp=$(date +\"%Y%m%d_%H%M%S\")\n    echo \"${REPORT_DIR}/${REPORT_PREFIX}_${timestamp}.${format}\"\n}\n\n# Write report header\nwrite_report_header() {\n    local file=\"$1\"\n    local format=\"$2\"\n    \n    case \"$format\" in\n        \"json\")\n            echo '{' > \"$file\"\n            echo '  \"metadata\": {' >> \"$file\"\n            echo \"    \\\"timestamp\\\": \\\"$(date -Iseconds)\\\",\" >> \"$file\"\n            echo \"    \\\"hostname\\\": \\\"$(hostname)\\\",\" >> \"$file\"\n            echo \"    \\\"kernel\\\": \\\"$(uname -r)\\\"\" >> \"$file\"\n            echo '  },' >> \"$file\"\n            echo '  \"data\": {' >> \"$file\"\n            ;;\n        \"csv\")\n            echo \"timestamp,metric,value,unit,status\" > \"$file\"\n            ;;\n        \"text\")\n            echo \"=== SYSTEM MONITORING REPORT ===\" > \"$file\"\n            echo \"Generated: $(date)\" >> \"$file\"\n            echo \"Hostname: $(hostname)\" >> \"$file\"\n            echo \"Kernel: $(uname -r)\" >> \"$file\"\n            echo \"================================\" >> \"$file\"\n            echo >> \"$file\"\n            ;;\n    esac\n}\n\n# Write report footer\nwrite_report_footer() {\n    local file=\"$1\"\n    local format=\"$2\"\n    \n    case \"$format\" in\n        \"json\")\n            # Remove trailing comma from last entry\n            sed -i '$ s/,$//' \"$file\"\n            echo '  }' >> \"$file\"\n            echo '}' >> \"$file\"\n            ;;\n        \"text\")\n            echo >> \"$file\"\n            echo \"================================\" >> \"$file\"\n            echo \"Report completed: $(date)\" >> \"$file\"\n            ;;\n    esac\n}\n\n# Append data to report\nappend_to_report() {\n    local file=\"$1\"\n    local format=\"$2\"\n    local metric=\"$3\"\n    local value=\"$4\"\n    local unit=\"$5\"\n    local status=\"$6\"\n    \n    case \"$format\" in\n        \"json\")\n            echo \"    \\\"$metric\\\": {\" >> \"$file\"\n            echo \"      \\\"value\\\": $value,\" >> \"$file\"\n            echo \"      \\\"unit\\\": \\\"$unit\\\",\" >> \"$file\"\n            echo \"      \\\"status\\\": \\\"$status\\\"\" >> \"$file\"\n            echo \"    },\" >> \"$file\"\n            ;;\n        \"csv\")\n            echo \"$(date -Iseconds),$metric,$value,$unit,$status\" >> \"$file\"\n            ;;\n        \"text\")\n            printf \"%-30s: %10s %-10s [%s]\\n\" \"$metric\" \"$value\" \"$unit\" \"$status\" >> \"$file\"\n            ;;\n    esac\n}\n\n# Clean old reports\nclean_old_reports() {\n    local max_age_days=\"${1:-$MAX_REPORT_AGE_DAYS}\"\n    local count=0\n    \n    log_info \"Cleaning reports older than $max_age_days days\"\n    \n    if [[ -d \"$REPORT_DIR\" ]]; then\n        while IFS= read -r file; do\n            rm -f \"$file\"\n            ((count++))\n        done < <(find \"$REPORT_DIR\" -name \"${REPORT_PREFIX}_*\" -type f -mtime +\"$max_age_days\")\n        \n        if (( count > 0 )); then\n            log_success \"Removed $count old report(s)\"\n        else\n            log_info \"No old reports to clean\"\n        fi\n    fi\n}\n\n# List recent reports\nlist_reports() {\n    local limit=\"${1:-10}\"\n    \n    if [[ -d \"$REPORT_DIR\" ]]; then\n        echo \"Recent reports (latest $limit):\"\n        find \"$REPORT_DIR\" -name \"${REPORT_PREFIX}_*\" -type f -printf \"%T@ %p\\n\" | \\\n            sort -nr | \\\n            head -n \"$limit\" | \\\n            while read -r timestamp file; do\n                size=$(stat -c \"%s\" \"$file\" 2>/dev/null || echo \"0\")\n                human_size=$(bytes_to_human \"$size\")\n                mod_time=$(date -d \"@${timestamp%.*}\" \"+%Y-%m-%d %H:%M:%S\")\n                printf \"  %-60s %10s  %s\\n\" \"$(basename \"$file\")\" \"$human_size\" \"$mod_time\"\n            done\n    else\n        log_warning \"Report directory does not exist: $REPORT_DIR\"\n    fi\n}\n\n# Archive reports\narchive_reports() {\n    local archive_name=\"${REPORT_DIR}/archive_$(date +%Y%m%d_%H%M%S).tar.gz\"\n    local count=0\n    \n    if [[ -d \"$REPORT_DIR\" ]]; then\n        # Count files to archive\n        count=$(find \"$REPORT_DIR\" -name \"${REPORT_PREFIX}_*\" -type f | wc -l)\n        \n        if (( count > 0 )); then\n            log_info \"Archiving $count report(s)\"\n            \n            # Create archive\n            tar -czf \"$archive_name\" -C \"$REPORT_DIR\" \\\n                $(find \"$REPORT_DIR\" -name \"${REPORT_PREFIX}_*\" -type f -printf \"%f \")\n            \n            if [[ $? -eq 0 ]]; then\n                # Remove archived files\n                find \"$REPORT_DIR\" -name \"${REPORT_PREFIX}_*\" -type f -delete\n                log_success \"Created archive: $archive_name\"\n            else\n                log_error \"Failed to create archive\"\n                return 1\n            fi\n        else\n            log_info \"No reports to archive\"\n        fi\n    fi\n}\n\necho \"✓ services/file_service.sh validated and saved\""
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "bash",
        "filename": "services/process_service.sh",
        "save": true,
        "session_id": "bash-monitor",
        "code": "#!/bin/bash\n# Process monitoring service functions\n\n# Source dependencies\nsource \"$(dirname \"${BASH_SOURCE[0]}\")/../lib/utils.sh\" 2>/dev/null || {\n    echo \"ERROR: Cannot source utils.sh\" >&2\n    exit 1\n}\n\nsource \"$(dirname \"${BASH_SOURCE[0]}\")/../config/settings.sh\" 2>/dev/null || {\n    echo \"ERROR: Cannot source settings.sh\" >&2\n    exit 1\n}\n\n# Get CPU usage percentage\nget_cpu_usage() {\n    local cpu_line\n    local idle_time\n    local total_time\n    \n    # Read CPU stats\n    cpu_line=$(head -1 \"$PROC_STAT\")\n    \n    # Extract CPU times\n    local user=$(echo \"$cpu_line\" | awk '{print $2}')\n    local nice=$(echo \"$cpu_line\" | awk '{print $3}')\n    local system=$(echo \"$cpu_line\" | awk '{print $4}')\n    local idle=$(echo \"$cpu_line\" | awk '{print $5}')\n    local iowait=$(echo \"$cpu_line\" | awk '{print $6}')\n    local irq=$(echo \"$cpu_line\" | awk '{print $7}')\n    local softirq=$(echo \"$cpu_line\" | awk '{print $8}')\n    \n    # Calculate total and idle time\n    total_time=$((user + nice + system + idle + iowait + irq + softirq))\n    idle_time=$idle\n    \n    # Store for next calculation\n    if [[ -n \"$PREV_TOTAL_TIME\" ]] && [[ -n \"$PREV_IDLE_TIME\" ]]; then\n        local diff_total=$((total_time - PREV_TOTAL_TIME))\n        local diff_idle=$((idle_time - PREV_IDLE_TIME))\n        \n        if (( diff_total > 0 )); then\n            local cpu_usage=$(echo \"scale=2; 100 * (1 - $diff_idle / $diff_total)\" | bc)\n            echo \"$cpu_usage\"\n        else\n            echo \"0.00\"\n        fi\n    else\n        echo \"0.00\"\n    fi\n    \n    # Export for next iteration\n    export PREV_TOTAL_TIME=$total_time\n    export PREV_IDLE_TIME=$idle_time\n}\n\n# Get memory usage information\nget_memory_info() {\n    local mem_total=$(grep \"^MemTotal:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    local mem_free=$(grep \"^MemFree:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    local mem_available=$(grep \"^MemAvailable:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    local buffers=$(grep \"^Buffers:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    local cached=$(grep \"^Cached:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    local swap_total=$(grep \"^SwapTotal:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    local swap_free=$(grep \"^SwapFree:\" \"$PROC_MEMINFO\" | awk '{print $2}')\n    \n    # Calculate used memory\n    local mem_used=$((mem_total - mem_available))\n    local swap_used=$((swap_total - swap_free))\n    \n    # Calculate percentages\n    local mem_percent=$(calculate_percentage \"$mem_used\" \"$mem_total\")\n    local swap_percent=\"0.00\"\n    if (( swap_total > 0 )); then\n        swap_percent=$(calculate_percentage \"$swap_used\" \"$swap_total\")\n    fi\n    \n    # Return as associative array string\n    echo \"mem_total=$mem_total\"\n    echo \"mem_used=$mem_used\"\n    echo \"mem_free=$mem_free\"\n    echo \"mem_percent=$mem_percent\"\n    echo \"swap_total=$swap_total\"\n    echo \"swap_used=$swap_used\"\n    echo \"swap_percent=$swap_percent\"\n}\n\n# Get disk usage for all mounted filesystems\nget_disk_usage() {\n    df -P | tail -n +2 | while read -r filesystem blocks used available percent mountpoint; do\n        # Skip special filesystems\n        if [[ \"$filesystem\" =~ ^(tmpfs|devtmpfs|udev|none)$ ]]; then\n            continue\n        fi\n        \n        # Remove % sign from percent\n        percent=\"${percent%\\%}\"\n        \n        # Determine status based on threshold\n        local status=\"OK\"\n        if (( percent >= DISK_CRITICAL_THRESHOLD )); then\n            status=\"CRITICAL\"\n        elif (( percent >= DISK_WARNING_THRESHOLD )); then\n            status=\"WARNING\"\n        fi\n        \n        echo \"filesystem=$filesystem\"\n        echo \"mountpoint=$mountpoint\"\n        echo \"total_blocks=$blocks\"\n        echo \"used_blocks=$used\"\n        echo \"available_blocks=$available\"\n        echo \"percent=$percent\"\n        echo \"status=$status\"\n        echo \"---\"\n    done\n}\n\n# Get top processes by CPU usage\nget_top_processes_by_cpu() {\n    local count=\"${1:-$TOP_PROCESSES_COUNT}\"\n    \n    ps aux --sort=-%cpu | head -n $((count + 1)) | tail -n +2 | \\\n    while read -r user pid cpu mem vsz rss tty stat start time command; do\n        # Truncate command if too long\n        if (( ${#command} > PROCESS_NAME_MAX_LENGTH )); then\n            command=\"${command:0:$((PROCESS_NAME_MAX_LENGTH - 3))}...\"\n        fi\n        \n        echo \"pid=$pid\"\n        echo \"user=$user\"\n        echo \"cpu=$cpu\"\n        echo \"mem=$mem\"\n        echo \"command=$command\"\n        echo \"---\"\n    done\n}\n\n# Get top processes by memory usage\nget_top_processes_by_memory() {\n    local count=\"${1:-$TOP_PROCESSES_COUNT}\"\n    \n    ps aux --sort=-%mem | head -n $((count + 1)) | tail -n +2 | \\\n    while read -r user pid cpu mem vsz rss tty stat start time command; do\n        # Truncate command if too long\n        if (( ${#command} > PROCESS_NAME_MAX_LENGTH )); then\n            command=\"${command:0:$((PROCESS_NAME_MAX_LENGTH - 3))}...\"\n        fi\n        \n        echo \"pid=$pid\"\n        echo \"user=$user\"\n        echo \"cpu=$cpu\"\n        echo \"mem=$mem\"\n        echo \"command=$command\"\n        echo \"---\"\n    done\n}\n\n# Check if a service is running on a port\ncheck_service_port() {\n    local port=\"$1\"\n    local service_name=\"${SERVICE_NAMES[$port]:-Unknown}\"\n    \n    # Check if port is listening\n    if netstat -tln 2>/dev/null | grep -q \":${port}\\s\"; then\n        echo \"port=$port\"\n        echo \"service=$service_name\"\n        echo \"status=LISTENING\"\n    else\n        echo \"port=$port\"\n        echo \"service=$service_name\"\n        echo \"status=NOT_LISTENING\"\n    fi\n}\n\n# Get system load average\nget_load_average() {\n    local load1 load5 load15 running_procs total_procs\n    \n    read -r load1 load5 load15 running_procs total_procs < \"$PROC_LOADAVG\"\n    \n    # Get number of CPUs\n    local cpu_count=$(nproc 2>/dev/null || echo \"1\")\n    \n    # Calculate normalized load (load per CPU)\n    local norm_load1=$(echo \"scale=2; $load1 / $cpu_count\" | bc)\n    local norm_load5=$(echo \"scale=2; $load5 / $cpu_count\" | bc)\n    local norm_load15=$(echo \"scale=2; $load15 / $cpu_count\" | bc)\n    \n    echo \"load1=$load1\"\n    echo \"load5=$load5\"\n    echo \"load15=$load15\"\n    echo \"norm_load1=$norm_load1\"\n    echo \"norm_load5=$norm_load5\"\n    echo \"norm_load15=$norm_load15\"\n    echo \"cpu_count=$cpu_count\"\n    echo \"running_procs=${running_procs%/*}\"\n    echo \"total_procs=${total_procs}\"\n}\n\n# Get system uptime\nget_system_uptime() {\n    local uptime_seconds\n    local idle_seconds\n    \n    read -r uptime_seconds idle_seconds < \"$PROC_UPTIME\"\n    \n    # Convert to days, hours, minutes\n    local days=$((${uptime_seconds%.*} / 86400))\n    local hours=$(( (${uptime_seconds%.*} % 86400) / 3600 ))\n    local minutes=$(( (${uptime_seconds%.*} % 3600) / 60 ))\n    \n    echo \"uptime_seconds=${uptime_seconds%.*}\"\n    echo \"uptime_days=$days\"\n    echo \"uptime_hours=$hours\"\n    echo \"uptime_minutes=$minutes\"\n    echo \"uptime_formatted=${days}d ${hours}h ${minutes}m\"\n}\n\necho \"✓ services/process_service.sh validated and saved\""
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 5,
    "method": "tools/call",
    "params": {
      "name": "execute_code",
      "arguments": {
        "language": "bash",
        "filename": "main.sh",
        "save": true,
        "session_id": "bash-monitor",
        "code": "#!/bin/bash\n# Main system monitoring and reporting tool\n\n# Get script directory\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\n# Source all required files\necho \"=== MULTI-FILE BASH SYSTEM MONITOR DEMO ===\"\necho\necho \"Loading components...\"\n\n# Source utilities\nif ! source \"${SCRIPT_DIR}/lib/utils.sh\"; then\n    echo \"ERROR: Failed to load utils.sh\" >&2\n    exit 1\nfi\nlog_success \"Loaded utility functions\"\n\n# Source configuration\nif ! source \"${SCRIPT_DIR}/config/settings.sh\"; then\n    log_error \"Failed to load settings.sh\"\n    exit 1\nfi\nlog_success \"Loaded configuration\"\n\n# Source services\nif ! source \"${SCRIPT_DIR}/services/file_service.sh\"; then\n    log_error \"Failed to load file_service.sh\"\n    exit 1\nfi\nlog_success \"Loaded file service\"\n\nif ! source \"${SCRIPT_DIR}/services/process_service.sh\"; then\n    log_error \"Failed to load process_service.sh\"\n    exit 1\nfi\nlog_success \"Loaded process service\"\n\n# Set up error handling\nset_error_trap\ntrap cleanup_on_exit EXIT\n\n# Validate configuration\necho\nlog_info \"Validating configuration...\"\nif ! validate_config; then\n    log_error \"Configuration validation failed\"\n    exit 1\nfi\nlog_success \"Configuration validated\"\n\n# Main monitoring function\nrun_system_monitor() {\n    local output_format=\"${1:-$DEFAULT_OUTPUT_FORMAT}\"\n    local report_file\n    \n    # Generate report filename\n    report_file=$(generate_report_filename \"$output_format\")\n    log_info \"Creating report: $report_file\"\n    \n    # Ensure report directory exists\n    ensure_directory \"$REPORT_DIR\"\n    \n    # Write report header\n    write_report_header \"$report_file\" \"$output_format\"\n    \n    # CPU Usage\n    if [[ \"$ENABLE_CPU_MONITORING\" == \"true\" ]]; then\n        log_info \"Checking CPU usage...\"\n        local cpu_usage=$(get_cpu_usage)\n        sleep 1  # Need a delay for accurate CPU calculation\n        cpu_usage=$(get_cpu_usage)\n        \n        local cpu_status=\"OK\"\n        if (( $(echo \"$cpu_usage >= $CPU_CRITICAL_THRESHOLD\" | bc -l) )); then\n            cpu_status=\"CRITICAL\"\n        elif (( $(echo \"$cpu_usage >= $CPU_WARNING_THRESHOLD\" | bc -l) )); then\n            cpu_status=\"WARNING\"\n        fi\n        \n        append_to_report \"$report_file\" \"$output_format\" \"CPU Usage\" \"$cpu_usage\" \"%\" \"$cpu_status\"\n        log_info \"CPU Usage: ${cpu_usage}% [$cpu_status]\"\n    fi\n    \n    # Memory Usage\n    if [[ \"$ENABLE_MEMORY_MONITORING\" == \"true\" ]]; then\n        log_info \"Checking memory usage...\"\n        \n        # Parse memory info into variables\n        eval \"$(get_memory_info)\"\n        \n        local mem_status=\"OK\"\n        if (( $(echo \"$mem_percent >= $MEMORY_CRITICAL_THRESHOLD\" | bc -l) )); then\n            mem_status=\"CRITICAL\"\n        elif (( $(echo \"$mem_percent >= $MEMORY_WARNING_THRESHOLD\" | bc -l) )); then\n            mem_status=\"WARNING\"\n        fi\n        \n        append_to_report \"$report_file\" \"$output_format\" \"Memory Usage\" \"$mem_percent\" \"%\" \"$mem_status\"\n        append_to_report \"$report_file\" \"$output_format\" \"Memory Used\" \"$(echo \"scale=2; $mem_used / 1024\" | bc)\" \"MB\" \"INFO\"\n        append_to_report \"$report_file\" \"$output_format\" \"Memory Total\" \"$(echo \"scale=2; $mem_total / 1024\" | bc)\" \"MB\" \"INFO\"\n        \n        log_info \"Memory Usage: ${mem_percent}% [$mem_status]\"\n    fi\n    \n    # Load Average\n    log_info \"Checking system load...\"\n    eval \"$(get_load_average)\"\n    \n    local load_status=\"OK\"\n    if (( $(echo \"$norm_load1 >= 2.0\" | bc -l) )); then\n        load_status=\"CRITICAL\"\n    elif (( $(echo \"$norm_load1 >= 1.0\" | bc -l) )); then\n        load_status=\"WARNING\"\n    fi\n    \n    append_to_report \"$report_file\" \"$output_format\" \"Load Average (1m)\" \"$load1\" \"load\" \"$load_status\"\n    append_to_report \"$report_file\" \"$output_format\" \"Load Average (5m)\" \"$load5\" \"load\" \"INFO\"\n    append_to_report \"$report_file\" \"$output_format\" \"Load Average (15m)\" \"$load15\" \"load\" \"INFO\"\n    \n    # System Uptime\n    log_info \"Checking system uptime...\"\n    eval \"$(get_system_uptime)\"\n    append_to_report \"$report_file\" \"$output_format\" \"System Uptime\" \"$uptime_formatted\" \"time\" \"INFO\"\n    \n    # Disk Usage\n    if [[ \"$ENABLE_DISK_MONITORING\" == \"true\" ]]; then\n        log_info \"Checking disk usage...\"\n        \n        local disk_data\n        local disk_entry=\"\"\n        \n        while IFS= read -r line; do\n            if [[ \"$line\" == \"---\" ]]; then\n                # Process accumulated disk entry\n                if [[ -n \"$disk_entry\" ]]; then\n                    eval \"$disk_entry\"\n                    append_to_report \"$report_file\" \"$output_format\" \"Disk $mountpoint\" \"$percent\" \"%\" \"$status\"\n                    log_info \"Disk $mountpoint: ${percent}% [$status]\"\n                fi\n                disk_entry=\"\"\n            else\n                disk_entry+=\"$line\"\n                disk_entry+=$'\\n'\n            fi\n        done < <(get_disk_usage)\n    fi\n    \n    # Top Processes\n    if [[ \"$ENABLE_PROCESS_MONITORING\" == \"true\" ]]; then\n        log_info \"Getting top processes by CPU...\"\n        \n        local process_count=0\n        local process_entry=\"\"\n        \n        while IFS= read -r line; do\n            if [[ \"$line\" == \"---\" ]]; then\n                if [[ -n \"$process_entry\" ]]; then\n                    eval \"$process_entry\"\n                    ((process_count++))\n                    if (( process_count <= 3 )); then  # Show top 3 in log\n                        log_info \"  PID $pid ($user): CPU ${cpu}% - $command\"\n                    fi\n                fi\n                process_entry=\"\"\n            else\n                process_entry+=\"$line\"\n                process_entry+=$'\\n'\n            fi\n        done < <(get_top_processes_by_cpu 5)\n    fi\n    \n    # Service Port Checks\n    if [[ \"$ENABLE_SERVICE_MONITORING\" == \"true\" ]]; then\n        log_info \"Checking service ports...\"\n        \n        for service in \"${!SERVICE_PORTS[@]}\"; do\n            local port=\"${SERVICE_PORTS[$service]}\"\n            eval \"$(check_service_port \"$port\")\"\n            \n            if [[ \"$status\" == \"LISTENING\" ]]; then\n                log_success \"  Service $service (port $port) is running\"\n            else\n                log_warning \"  Service $service (port $port) is not running\"\n            fi\n        done\n    fi\n    \n    # Write report footer\n    write_report_footer \"$report_file\" \"$output_format\"\n    \n    log_success \"Report saved to: $report_file\"\n    \n    # Display report content for text format\n    if [[ \"$output_format\" == \"text\" ]]; then\n        echo\n        echo \"=== REPORT CONTENT ===\"\n        cat \"$report_file\"\n    fi\n}\n\n# Command line argument parsing\nparse_arguments() {\n    local format=\"$DEFAULT_OUTPUT_FORMAT\"\n    local action=\"monitor\"\n    \n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            --format|-f)\n                format=\"$2\"\n                shift 2\n                ;;\n            --list|-l)\n                action=\"list\"\n                shift\n                ;;\n            --clean|-c)\n                action=\"clean\"\n                shift\n                ;;\n            --archive|-a)\n                action=\"archive\"\n                shift\n                ;;\n            --help|-h)\n                action=\"help\"\n                shift\n                ;;\n            *)\n                log_error \"Unknown option: $1\"\n                action=\"help\"\n                shift\n                ;;\n        esac\n    done\n    \n    echo \"$action|$format\"\n}\n\n# Show help\nshow_help() {\n    echo \"Usage: $0 [OPTIONS]\"\n    echo\n    echo \"Options:\"\n    echo \"  -f, --format FORMAT   Output format (text, json, csv). Default: text\"\n    echo \"  -l, --list           List recent reports\"\n    echo \"  -c, --clean          Clean old reports\"\n    echo \"  -a, --archive        Archive existing reports\"\n    echo \"  -h, --help           Show this help message\"\n    echo\n    echo \"Examples:\"\n    echo \"  $0                   # Run monitor with text output\"\n    echo \"  $0 -f json           # Run monitor with JSON output\"\n    echo \"  $0 --list            # List recent reports\"\n    echo \"  $0 --clean           # Clean old reports\"\n}\n\n# Main execution\necho\nlog_info \"=== SYSTEM MONITORING STARTED ===\"\n\n# Parse command line arguments\nIFS='|' read -r action format <<< \"$(parse_arguments \"$@\")\"\n\n# Execute requested action\ncase \"$action\" in\n    \"monitor\")\n        run_system_monitor \"$format\"\n        ;;\n    \"list\")\n        list_reports\n        ;;\n    \"clean\")\n        clean_old_reports\n        ;;\n    \"archive\")\n        archive_reports\n        ;;\n    \"help\")\n        show_help\n        ;;\nesac\n\necho\nlog_success \"=== MONITORING COMPLETED ===\"\necho\necho \"✅ Multi-file Bash application demo completed!\"\necho\necho \"🔄 All scripts persist within this container session\"\necho \"🗑️  Files will be cleaned up when container restarts\"\necho \"🔒 Host system remains completely isolated\"\necho\necho \"📊 This demo showed:\"\necho \"   - Function libraries and sourcing\"\necho \"   - Configuration management\"\necho \"   - Service-oriented architecture\"\necho \"   - Arrays and associative arrays\"\necho \"   - String manipulation and formatting\"\necho \"   - File operations and reporting\"\necho \"   - Process monitoring and management\"\necho \"   - Error handling with traps\"\necho \"   - Command substitution and pipes\"\necho \"   - Advanced Bash scripting patterns\""
      }
    }
  }
]