[
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "clojure",
        "filename": "models.clj",
        "save": true,
        "session_id": "clojure-recipes",
        "code": ";; Data models and specs for recipe management system\n(ns recipes.models\n  (:require [clojure.spec.alpha :as s]))\n\n;; Specs for data validation\n(s/def ::id pos-int?)\n(s/def ::name (s/and string? #(not (clojure.string/blank? %))))\n(s/def ::email (s/and string? #(re-matches #\".+@.+\\..+\" %)))\n(s/def ::ingredient-name ::name)\n(s/def ::quantity pos?)\n(s/def ::unit #{:cup :tbsp :tsp :oz :lb :g :kg :ml :l :piece})\n(s/def ::prep-time pos-int?)\n(s/def ::cook-time pos-int?)\n(s/def ::servings pos-int?)\n(s/def ::difficulty #{:easy :medium :hard})\n(s/def ::rating (s/and number? #(<= 1 % 5)))\n\n;; Ingredient structure\n(s/def ::ingredient\n  (s/keys :req-un [::ingredient-name ::quantity ::unit]))\n\n;; Recipe structure\n(s/def ::recipe\n  (s/keys :req-un [::id ::name ::ingredients ::instructions\n                   ::prep-time ::cook-time ::servings]\n          :opt-un [::difficulty ::rating ::tags]))\n\n;; User structure\n(s/def ::user\n  (s/keys :req-un [::id ::name ::email]\n          :opt-un [::favorite-recipes]))\n\n;; Multi-method for formatting ingredients\n(defmulti format-ingredient :unit)\n\n(defmethod format-ingredient :cup [{:keys [ingredient-name quantity]}]\n  (str quantity \" cup\" (when (> quantity 1) \"s\") \" \" ingredient-name))\n\n(defmethod format-ingredient :tbsp [{:keys [ingredient-name quantity]}]\n  (str quantity \" tbsp \" ingredient-name))\n\n(defmethod format-ingredient :tsp [{:keys [ingredient-name quantity]}]\n  (str quantity \" tsp \" ingredient-name))\n\n(defmethod format-ingredient :piece [{:keys [ingredient-name quantity]}]\n  (str quantity \" \" ingredient-name (when (> quantity 1) \"s\")))\n\n(defmethod format-ingredient :default [{:keys [ingredient-name quantity unit]}]\n  (str quantity \" \" (name unit) \" \" ingredient-name))\n\n;; Recipe constructor with validation\n(defn make-recipe\n  \"Create a new recipe with validation\"\n  [{:keys [name ingredients instructions prep-time cook-time servings]\n    :as recipe-data}]\n  (let [recipe (assoc recipe-data :id (rand-int 10000))]\n    (if (s/valid? ::recipe recipe)\n      recipe\n      (throw (ex-info \"Invalid recipe data\"\n                      {:errors (s/explain-data ::recipe recipe)})))))\n\n;; Helper to calculate total time\n(defn total-time\n  \"Calculate total cooking time for a recipe\"\n  [{:keys [prep-time cook-time]}]\n  (+ prep-time cook-time))\n\n(println \"âœ“ models.clj validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "clojure",
        "filename": "utils.clj",
        "save": true,
        "session_id": "clojure-recipes",
        "code": ";; Utility functions and transformations\n(ns recipes.utils\n  (:require [clojure.string :as str]))\n\n;; Text processing utilities\n(defn normalize-text\n  \"Normalize text for searching and comparison\"\n  [text]\n  (-> text\n      str/lower-case\n      str/trim))\n\n(defn titleize\n  \"Convert string to title case\"\n  [s]\n  (->> (str/split s #\"\\s+\")\n       (map str/capitalize)\n       (str/join \" \")))\n\n;; Time formatting\n(defn format-time\n  \"Format minutes into human-readable time\"\n  [minutes]\n  (let [hours (quot minutes 60)\n        mins (rem minutes 60)]\n    (cond\n      (zero? hours) (str mins \" minutes\")\n      (zero? mins) (str hours \" hour\" (when (> hours 1) \"s\"))\n      :else (str hours \" hour\" (when (> hours 1) \"s\") \" \" mins \" minutes\"))))\n\n;; Collection utilities using higher-order functions\n(defn find-by\n  \"Find first item in collection matching predicate\"\n  [pred coll]\n  (first (filter pred coll)))\n\n(defn group-by-multi\n  \"Group items by multiple keys\"\n  [key-fns coll]\n  (reduce (fn [acc item]\n            (reduce (fn [acc' key-fn]\n                      (let [k (key-fn item)]\n                        (update acc' k (fnil conj []) item)))\n                    acc\n                    key-fns))\n          {}\n          coll))\n\n;; Recipe-specific transformations\n(defn scale-recipe\n  \"Scale recipe ingredients by a factor\"\n  [recipe factor]\n  (update recipe :ingredients\n          (fn [ingredients]\n            (map #(update % :quantity * factor) ingredients))))\n\n(defn recipe->shopping-list\n  \"Convert multiple recipes to a shopping list\"\n  [recipes]\n  (->> recipes\n       (mapcat :ingredients)\n       (group-by :ingredient-name)\n       (map (fn [[name ingredients]]\n              {:ingredient-name name\n               :total-quantity (reduce + (map :quantity ingredients))\n               :units (set (map :unit ingredients))}))))\n\n;; Threading macro example for data pipeline\n(defn process-recipe-name\n  \"Process recipe name through multiple transformations\"\n  [name]\n  (-> name\n      normalize-text\n      titleize\n      (str/replace #\"\\s+\" \" \")\n      (str/replace #\"[^a-zA-Z0-9\\s]\" \"\")))\n\n;; Functional composition\n(def extract-tags\n  \"Extract tags from recipe name and ingredients\"\n  (comp set\n        (partial remove str/blank?)\n        (partial map normalize-text)\n        (partial mapcat #(str/split % #\"\\s+\"))\n        (fn [{:keys [name ingredients]}]\n          (cons name (map :ingredient-name ingredients)))))\n\n;; Predicate functions\n(defn quick-recipe?\n  \"Check if recipe can be made in under 30 minutes\"\n  [{:keys [prep-time cook-time]}]\n  (< (+ prep-time cook-time) 30))\n\n(defn vegetarian?\n  \"Check if recipe is vegetarian based on ingredients\"\n  [{:keys [ingredients]}]\n  (let [meat-keywords #{\"chicken\" \"beef\" \"pork\" \"fish\" \"lamb\" \"turkey\" \"bacon\"}]\n    (not-any? (fn [ingredient]\n                (some #(str/includes? (normalize-text (:ingredient-name ingredient)) %)\n                      meat-keywords))\n              ingredients)))\n\n(println \"âœ“ utils.clj validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "clojure",
        "filename": "services.clj",
        "save": true,
        "session_id": "clojure-recipes",
        "code": ";; Recipe service functions with state management\n(ns recipes.services\n  (:require [recipes.models :as models]\n            [recipes.utils :as utils]\n            [clojure.spec.alpha :as s]))\n\n;; Atoms for state management\n(def recipes-db (atom {}))\n(def users-db (atom {}))\n(def next-recipe-id (atom 1))\n(def next-user-id (atom 1))\n\n;; User management functions\n(defn create-user!\n  \"Create a new user and add to database\"\n  [{:keys [name email] :as user-data}]\n  (let [id @next-user-id\n        user (assoc user-data :id id :favorite-recipes #{})]]\n    (if (s/valid? :recipes.models/user user)\n      (do\n        (swap! users-db assoc id user)\n        (swap! next-user-id inc)\n        user)\n      (throw (ex-info \"Invalid user data\" {:user user})))))\n\n(defn get-user [id]\n  (get @users-db id))\n\n;; Recipe CRUD operations\n(defn create-recipe!\n  \"Create a new recipe and add to database\"\n  [recipe-data]\n  (let [id @next-recipe-id\n        recipe (assoc recipe-data :id id :created-at (System/currentTimeMillis))]\n    (if (s/valid? :recipes.models/recipe recipe)\n      (do\n        (swap! recipes-db assoc id recipe)\n        (swap! next-recipe-id inc)\n        recipe)\n      (throw (ex-info \"Invalid recipe data\" {:recipe recipe})))))\n\n(defn get-recipe [id]\n  (get @recipes-db id))\n\n(defn update-recipe!\n  \"Update an existing recipe\"\n  [id updates]\n  (if-let [recipe (get-recipe id)]\n    (let [updated (merge recipe updates)]\n      (if (s/valid? :recipes.models/recipe updated)\n        (do\n          (swap! recipes-db assoc id updated)\n          updated)\n        (throw (ex-info \"Invalid recipe update\" {:updates updates}))))\n    (throw (ex-info \"Recipe not found\" {:id id}))))\n\n(defn delete-recipe! [id]\n  (swap! recipes-db dissoc id)\n  {:deleted id})\n\n;; Recipe search and filtering\n(defn search-recipes\n  \"Search recipes by name or ingredient\"\n  [query]\n  (let [normalized-query (utils/normalize-text query)]\n    (->> @recipes-db\n         vals\n         (filter (fn [recipe]\n                   (or (str/includes? (utils/normalize-text (:name recipe))\n                                      normalized-query)\n                       (some #(str/includes? (utils/normalize-text (:ingredient-name %))\n                                             normalized-query)\n                             (:ingredients recipe))))))))\n\n(defn filter-recipes\n  \"Filter recipes by multiple criteria\"\n  [{:keys [max-time difficulty vegetarian min-rating]}]\n  (cond->> (vals @recipes-db)\n    max-time (filter #(<= (models/total-time %) max-time))\n    difficulty (filter #(= (:difficulty %) difficulty))\n    vegetarian (filter utils/vegetarian?)\n    min-rating (filter #(>= (or (:rating %) 0) min-rating))))\n\n;; User favorites management\n(defn add-favorite!\n  \"Add recipe to user's favorites\"\n  [user-id recipe-id]\n  (if (and (get-user user-id) (get-recipe recipe-id))\n    (do\n      (swap! users-db update-in [user-id :favorite-recipes] conj recipe-id)\n      {:user-id user-id :recipe-id recipe-id :action :added})\n    (throw (ex-info \"User or recipe not found\" \n                    {:user-id user-id :recipe-id recipe-id}))))\n\n(defn remove-favorite!\n  \"Remove recipe from user's favorites\"\n  [user-id recipe-id]\n  (swap! users-db update-in [user-id :favorite-recipes] disj recipe-id)\n  {:user-id user-id :recipe-id recipe-id :action :removed})\n\n(defn get-user-favorites\n  \"Get all favorite recipes for a user\"\n  [user-id]\n  (when-let [user (get-user user-id)]\n    (->> (:favorite-recipes user)\n         (map get-recipe)\n         (remove nil?))))\n\n;; Recipe recommendations\n(defn recommend-recipes\n  \"Recommend recipes based on user's favorites\"\n  [user-id]\n  (let [favorites (get-user-favorites user-id)\n        favorite-ingredients (->> favorites\n                                  (mapcat :ingredients)\n                                  (map :ingredient-name)\n                                  frequencies\n                                  (sort-by val >)\n                                  (take 5)\n                                  (map first)\n                                  set)]\n    (->> (vals @recipes-db)\n         (remove #(contains? (set (map :id favorites)) (:id %)))\n         (map (fn [recipe]\n                (let [matching-ingredients \n                      (count (filter #(contains? favorite-ingredients \n                                                 (:ingredient-name %))\n                                     (:ingredients recipe)))]\n                  [matching-ingredients recipe])))\n         (filter #(> (first %) 0))\n         (sort-by first >)\n         (take 5)\n         (map second))))\n\n;; Analytics functions\n(defn recipe-stats\n  \"Get statistics about recipes in the database\"\n  []\n  (let [all-recipes (vals @recipes-db)]\n    {:total-recipes (count all-recipes)\n     :average-prep-time (when (seq all-recipes)\n                          (/ (reduce + (map :prep-time all-recipes))\n                             (count all-recipes)))\n     :difficulty-distribution (frequencies (map :difficulty all-recipes))\n     :quick-recipes (count (filter utils/quick-recipe? all-recipes))\n     :vegetarian-recipes (count (filter utils/vegetarian? all-recipes))\n     :top-rated (->> all-recipes\n                     (filter :rating)\n                     (sort-by :rating >)\n                     (take 3)\n                     (map #(select-keys % [:id :name :rating])))}))\n\n(println \"âœ“ services.clj validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "execute_code",
      "arguments": {
        "language": "clojure",
        "filename": "main.clj",
        "save": true,
        "session_id": "clojure-recipes",
        "code": "#!/usr/bin/env clojure\n;; Main application demonstrating the recipe management system\n\n(println \"=== MULTI-FILE CLOJURE RECIPE MANAGEMENT DEMO ===\")\n(println)\n\n;; Load our namespaces\n(try\n  (require '[recipes.models :as models]\n           '[recipes.utils :as utils]\n           '[recipes.services :as services])\n  (println \"âœ“ All namespaces loaded successfully\")\n  (catch Exception e\n    (println \"âœ— Failed to load namespaces:\" (.getMessage e))\n    (System/exit 1)))\n\n(println)\n(println \"=== CREATING USERS ===\")\n\n;; Create some users using destructuring\n(let [{:keys [id name] :as alice} (services/create-user! {:name \"Alice Cooper\"\n                                                           :email \"alice@recipes.com\"})\n      bob (services/create-user! {:name \"Bob Dylan\"\n                                   :email \"bob@cooking.com\"})]\n  (println \"Created user:\" name \"with ID:\" id)\n  (println \"Created user:\" (:name bob) \"with ID:\" (:id bob)))\n\n(println)\n(println \"=== CREATING RECIPES ===\")\n\n;; Create recipes demonstrating various Clojure features\n(def pasta-recipe\n  (services/create-recipe!\n   {:name \"Classic Spaghetti Carbonara\"\n    :ingredients [{:ingredient-name \"spaghetti\" :quantity 1 :unit :lb}\n                  {:ingredient-name \"bacon\" :quantity 8 :unit :piece}\n                  {:ingredient-name \"eggs\" :quantity 4 :unit :piece}\n                  {:ingredient-name \"parmesan cheese\" :quantity 1 :unit :cup}\n                  {:ingredient-name \"black pepper\" :quantity 2 :unit :tsp}]\n    :instructions [\"Cook spaghetti according to package directions\"\n                   \"Cook bacon until crispy, reserve fat\"\n                   \"Beat eggs with cheese and pepper\"\n                   \"Toss hot pasta with bacon fat\"\n                   \"Remove from heat, add egg mixture\"\n                   \"Toss quickly to create creamy sauce\"]\n    :prep-time 10\n    :cook-time 20\n    :servings 4\n    :difficulty :medium\n    :rating 4.5}))\n\n(println \"Created recipe:\" (:name pasta-recipe))\n\n;; Using threading macro to create and process recipe\n(def salad-recipe\n  (-> {:name \"  mediterranean  quinoa  SALAD  \"\n       :ingredients [{:ingredient-name \"quinoa\" :quantity 2 :unit :cup}\n                     {:ingredient-name \"cucumber\" :quantity 1 :unit :piece}\n                     {:ingredient-name \"tomatoes\" :quantity 3 :unit :piece}\n                     {:ingredient-name \"feta cheese\" :quantity 0.5 :unit :cup}\n                     {:ingredient-name \"olive oil\" :quantity 3 :unit :tbsp}]\n       :instructions [\"Cook quinoa and let cool\"\n                      \"Dice vegetables\"\n                      \"Mix everything together\"\n                      \"Drizzle with olive oil\"]\n       :prep-time 15\n       :cook-time 15\n       :servings 6\n       :difficulty :easy\n       :rating 4.8}\n      (update :name utils/process-recipe-name)\n      services/create-recipe!))\n\n(println \"Created recipe:\" (:name salad-recipe))\n\n;; Create a quick recipe\n(def smoothie-recipe\n  (services/create-recipe!\n   {:name \"Green Power Smoothie\"\n    :ingredients [{:ingredient-name \"spinach\" :quantity 2 :unit :cup}\n                  {:ingredient-name \"banana\" :quantity 1 :unit :piece}\n                  {:ingredient-name \"almond milk\" :quantity 1 :unit :cup}\n                  {:ingredient-name \"protein powder\" :quantity 1 :unit :oz}]\n    :instructions [\"Blend all ingredients until smooth\"]\n    :prep-time 5\n    :cook-time 0\n    :servings 1\n    :difficulty :easy}))\n\n(println \"Created recipe:\" (:name smoothie-recipe))\n\n(println)\n(println \"=== DEMONSTRATING MULTI-METHODS ===\")\n\n;; Show ingredient formatting with multi-methods\n(doseq [ingredient (take 3 (:ingredients pasta-recipe))]\n  (println \"-\" (models/format-ingredient ingredient)))\n\n(println)\n(println \"=== RECIPE TRANSFORMATIONS ===\")\n\n;; Scale recipe using higher-order functions\n(let [scaled (utils/scale-recipe pasta-recipe 2)]\n  (println \"Scaled carbonara to\" (* 2 (:servings pasta-recipe)) \"servings:\")\n  (doseq [ing (take 2 (:ingredients scaled))]\n    (println \"-\" (models/format-ingredient ing))))\n\n(println)\n(println \"=== SEARCHING AND FILTERING ===\")\n\n;; Search recipes\n(let [results (services/search-recipes \"quinoa\")]\n  (println \"Search results for 'quinoa':\" (count results) \"found\")\n  (doseq [r results]\n    (println \"-\" (:name r))))\n\n;; Filter recipes with multiple criteria\n(let [quick-easy (services/filter-recipes {:max-time 25 :difficulty :easy})]\n  (println \"\\nQuick and easy recipes:\")\n  (doseq [r quick-easy]\n    (println \"-\" (:name r) \"(\" (utils/format-time (models/total-time r)) \")\")))\n\n(println)\n(println \"=== USER FAVORITES ===\")\n\n;; Add favorites using let bindings\n(let [alice-id 1\n      _ (services/add-favorite! alice-id (:id pasta-recipe))\n      _ (services/add-favorite! alice-id (:id salad-recipe))\n      favorites (services/get-user-favorites alice-id)]\n  (println \"Alice's favorite recipes:\")\n  (doseq [fav favorites]\n    (println \"-\" (:name fav))))\n\n(println)\n(println \"=== RECOMMENDATIONS ===\")\n\n;; Get recommendations based on favorites\n(let [recommendations (services/recommend-recipes 1)]\n  (println \"Recommended recipes for Alice:\")\n  (if (empty? recommendations)\n    (println \"(No recommendations yet - add more recipes!)\")\n    (doseq [rec recommendations]\n      (println \"-\" (:name rec)))))\n\n(println)\n(println \"=== SHOPPING LIST GENERATION ===\")\n\n;; Generate shopping list using map/reduce\n(let [alice-favorites (services/get-user-favorites 1)\n      shopping-list (utils/recipe->shopping-list alice-favorites)]\n  (println \"Shopping list for Alice's favorites:\")\n  (doseq [{:keys [ingredient-name total-quantity units]} shopping-list]\n    (println \"-\" (str total-quantity \" \" (first units) \" \" ingredient-name))))\n\n(println)\n(println \"=== RECIPE STATISTICS ===\")\n\n;; Show analytics using atoms and aggregation\n(let [stats (services/recipe-stats)]\n  (println \"Database statistics:\")\n  (println \"- Total recipes:\" (:total-recipes stats))\n  (println \"- Average prep time:\" (utils/format-time (int (:average-prep-time stats))))\n  (println \"- Quick recipes:\" (:quick-recipes stats))\n  (println \"- Vegetarian recipes:\" (:vegetarian-recipes stats))\n  (println \"- Difficulty distribution:\" (:difficulty-distribution stats))\n  (when (seq (:top-rated stats))\n    (println \"- Top rated recipes:\")\n    (doseq [r (:top-rated stats)]\n      (println \"  *\" (:name r) \"- Rating:\" (:rating r)))))\n\n(println)\n(println \"=== FUNCTIONAL COMPOSITION EXAMPLE ===\")\n\n;; Extract tags using function composition\n(let [tags (utils/extract-tags salad-recipe)]\n  (println \"Tags extracted from\" (:name salad-recipe) \":\")\n  (println (clojure.string/join \", \" (take 10 tags))))\n\n(println)\n(println \"âœ… Multi-file Clojure recipe management demo completed!\")\n(println)\n(println \"ðŸ”„ All namespaces and data persist within this container session\")\n(println \"ðŸ—‘ï¸  State will be reset when container restarts\")\n(println \"ðŸ”’ Host system remains completely isolated\")\n(println)\n(println \"Key Clojure features demonstrated:\")\n(println \"- Maps and vectors for data structures\")\n(println \"- Destructuring in let bindings\")\n(println \"- Higher-order functions (map, filter, reduce)\")\n(println \"- Threading macros (-> and ->>)\")\n(println \"- Multi-methods for polymorphic dispatch\")\n(println \"- Atoms for state management\")\n(println \"- Namespace organization\")\n(println \"- Spec for data validation\")"
      }
    }
  }
]