[
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "kotlin",
        "filename": "models.kts",
        "save": true,
        "session_id": "kotlin-library",
        "code": "// Data models for our Library Management System\nimport java.time.LocalDate\nimport java.time.format.DateTimeFormatter\n\n// Data class for Book\ndata class Book(\n    val isbn: String,\n    val title: String,\n    val author: String,\n    val publishedDate: LocalDate,\n    val genre: Genre,\n    val availableCopies: Int = 1\n) {\n    companion object {\n        fun fromString(data: String): Book? {\n            val parts = data.split(\"|\")\n            return if (parts.size == 6) {\n                Book(\n                    isbn = parts[0],\n                    title = parts[1],\n                    author = parts[2],\n                    publishedDate = LocalDate.parse(parts[3]),\n                    genre = Genre.valueOf(parts[4]),\n                    availableCopies = parts[5].toInt()\n                )\n            } else null\n        }\n    }\n    \n    fun toFormattedString(): String = \n        \"📚 $title by $author (ISBN: $isbn)\\n\" +\n        \"   Genre: $genre | Published: ${publishedDate.format(DateTimeFormatter.ISO_LOCAL_DATE)}\"\n}\n\n// Data class for Member\ndata class Member(\n    val id: Int,\n    val name: String,\n    val email: String,\n    val membershipType: MembershipType,\n    val joinDate: LocalDate = LocalDate.now()\n) {\n    fun getMaxBorrowLimit(): Int = when (membershipType) {\n        is MembershipType.Regular -> membershipType.borrowLimit\n        is MembershipType.Premium -> membershipType.borrowLimit\n        is MembershipType.Student -> membershipType.borrowLimit\n    }\n}\n\n// Data class for Loan\ndata class Loan(\n    val id: Int,\n    val memberId: Int,\n    val bookIsbn: String,\n    val loanDate: LocalDate = LocalDate.now(),\n    val dueDate: LocalDate = loanDate.plusDays(14),\n    val returnDate: LocalDate? = null\n) {\n    val isOverdue: Boolean\n        get() = returnDate == null && LocalDate.now().isAfter(dueDate)\n    \n    val daysOverdue: Long\n        get() = if (isOverdue) {\n            LocalDate.now().toEpochDay() - dueDate.toEpochDay()\n        } else 0\n}\n\n// Enum for book genres\nenum class Genre {\n    FICTION, NON_FICTION, SCIENCE, HISTORY, BIOGRAPHY, \n    MYSTERY, ROMANCE, THRILLER, FANTASY, TECHNICAL\n}\n\n// Sealed class for membership types\nsealed class MembershipType(val borrowLimit: Int) {\n    object Regular : MembershipType(3)\n    object Premium : MembershipType(10)\n    object Student : MembershipType(5)\n    \n    fun describe(): String = when (this) {\n        is Regular -> \"Regular membership (up to $borrowLimit books)\"\n        is Premium -> \"Premium membership (up to $borrowLimit books)\"\n        is Student -> \"Student membership (up to $borrowLimit books)\"\n    }\n}\n\n// Sealed class for operation results\nsealed class OperationResult<out T> {\n    data class Success<T>(val data: T) : OperationResult<T>()\n    data class Error(val message: String) : OperationResult<Nothing>()\n    \n    inline fun onSuccess(action: (T) -> Unit): OperationResult<T> {\n        if (this is Success) action(data)\n        return this\n    }\n    \n    inline fun onError(action: (String) -> Unit): OperationResult<T> {\n        if (this is Error) action(message)\n        return this\n    }\n}\n\nprintln(\"✓ models.kts validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "kotlin",
        "filename": "extensions.kts",
        "save": true,
        "session_id": "kotlin-library",
        "code": "// Extension functions and utilities for Library Management System\nimport java.time.LocalDate\nimport java.time.format.DateTimeFormatter\n\n// Extension function for String to validate ISBN\nfun String.isValidIsbn(): Boolean {\n    val cleanIsbn = this.replace(\"-\", \"\").replace(\" \", \"\")\n    return when (cleanIsbn.length) {\n        10 -> cleanIsbn.all { it.isDigit() || it == 'X' }\n        13 -> cleanIsbn.all { it.isDigit() }\n        else -> false\n    }\n}\n\n// Extension function for String to validate email\nfun String.isValidEmail(): Boolean = \n    this.matches(Regex(\"^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"))\n\n// Extension function for LocalDate formatting\nfun LocalDate.toReadableString(): String = \n    this.format(DateTimeFormatter.ofPattern(\"MMM dd, yyyy\"))\n\n// Extension function for List of Books\nfun List<Book>.filterByGenre(genre: Genre): List<Book> = \n    this.filter { it.genre == genre }\n\nfun List<Book>.filterByAuthor(author: String): List<Book> = \n    this.filter { it.author.contains(author, ignoreCase = true) }\n\nfun List<Book>.sortByTitle(): List<Book> = \n    this.sortedBy { it.title }\n\nfun List<Book>.groupByGenre(): Map<Genre, List<Book>> = \n    this.groupBy { it.genre }\n\n// Extension function for List of Loans\nfun List<Loan>.getActiveLoans(): List<Loan> = \n    this.filter { it.returnDate == null }\n\nfun List<Loan>.getOverdueLoans(): List<Loan> = \n    this.filter { it.isOverdue }\n\n// Utility functions using lambda expressions\nfun <T> measureTimeMillis(block: () -> T): Pair<T, Long> {\n    val start = System.currentTimeMillis()\n    val result = block()\n    val time = System.currentTimeMillis() - start\n    return result to time\n}\n\n// Higher-order function for retry logic\nfun <T> retry(times: Int = 3, delay: Long = 1000, block: () -> T): T? {\n    repeat(times - 1) {\n        try {\n            return block()\n        } catch (e: Exception) {\n            Thread.sleep(delay)\n        }\n    }\n    return try {\n        block()\n    } catch (e: Exception) {\n        null\n    }\n}\n\n// Infix function for creating date ranges\ninfix fun LocalDate.until(other: LocalDate): List<LocalDate> {\n    val dates = mutableListOf<LocalDate>()\n    var current = this\n    while (!current.isAfter(other)) {\n        dates.add(current)\n        current = current.plusDays(1)\n    }\n    return dates\n}\n\n// DSL-style builder for creating books\nclass BookBuilder {\n    var isbn: String = \"\"\n    var title: String = \"\"\n    var author: String = \"\"\n    var publishedDate: LocalDate = LocalDate.now()\n    var genre: Genre = Genre.FICTION\n    var availableCopies: Int = 1\n    \n    fun build(): Book = Book(isbn, title, author, publishedDate, genre, availableCopies)\n}\n\nfun book(init: BookBuilder.() -> Unit): Book {\n    val builder = BookBuilder()\n    builder.init()\n    return builder.build()\n}\n\n// String template utilities\nfun formatBookList(books: List<Book>): String = buildString {\n    appendLine(\"📚 Book Collection (${books.size} books)\")\n    appendLine(\"=\".repeat(40))\n    books.forEachIndexed { index, book ->\n        appendLine(\"${index + 1}. ${book.title}\")\n        appendLine(\"   Author: ${book.author}\")\n        appendLine(\"   Genre: ${book.genre}\")\n        if (index < books.size - 1) appendLine()\n    }\n}\n\nprintln(\"✓ extensions.kts validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "kotlin",
        "filename": "services.kts",
        "save": true,
        "session_id": "kotlin-library",
        "code": "// Service layer for Library Management System\nimport java.time.LocalDate\nimport kotlin.random.Random\n\n// Library service with coroutine-like concepts (simulated)\nclass LibraryService {\n    private val books = mutableListOf<Book>()\n    private val members = mutableListOf<Member>()\n    private val loans = mutableListOf<Loan>()\n    private var nextLoanId = 1\n    private var nextMemberId = 1\n    \n    // Book management\n    fun addBook(book: Book): OperationResult<Book> {\n        return if (book.isbn.isValidIsbn()) {\n            books.add(book)\n            OperationResult.Success(book)\n        } else {\n            OperationResult.Error(\"Invalid ISBN format\")\n        }\n    }\n    \n    fun findBookByIsbn(isbn: String): Book? = \n        books.find { it.isbn == isbn }\n    \n    fun searchBooks(query: String): List<Book> = \n        books.filter { book ->\n            book.title.contains(query, ignoreCase = true) ||\n            book.author.contains(query, ignoreCase = true)\n        }\n    \n    // Member management\n    fun registerMember(\n        name: String, \n        email: String, \n        type: MembershipType = MembershipType.Regular\n    ): OperationResult<Member> {\n        return if (email.isValidEmail()) {\n            val member = Member(nextMemberId++, name, email, type)\n            members.add(member)\n            OperationResult.Success(member)\n        } else {\n            OperationResult.Error(\"Invalid email format\")\n        }\n    }\n    \n    fun findMemberById(id: Int): Member? = \n        members.find { it.id == id }\n    \n    // Loan management\n    fun borrowBook(memberId: Int, isbn: String): OperationResult<Loan> {\n        val member = findMemberById(memberId) \n            ?: return OperationResult.Error(\"Member not found\")\n        \n        val book = findBookByIsbn(isbn) \n            ?: return OperationResult.Error(\"Book not found\")\n        \n        val activeLoans = loans.getActiveLoans().count { it.memberId == memberId }\n        \n        return when {\n            activeLoans >= member.getMaxBorrowLimit() -> \n                OperationResult.Error(\"Member has reached borrowing limit\")\n            book.availableCopies <= 0 -> \n                OperationResult.Error(\"No copies available\")\n            else -> {\n                val loan = Loan(nextLoanId++, memberId, isbn)\n                loans.add(loan)\n                // Update available copies (in real app, this would be atomic)\n                val updatedBook = book.copy(availableCopies = book.availableCopies - 1)\n                books[books.indexOf(book)] = updatedBook\n                OperationResult.Success(loan)\n            }\n        }\n    }\n    \n    fun returnBook(loanId: Int): OperationResult<Loan> {\n        val loan = loans.find { it.id == loanId && it.returnDate == null }\n            ?: return OperationResult.Error(\"Active loan not found\")\n        \n        val updatedLoan = loan.copy(returnDate = LocalDate.now())\n        loans[loans.indexOf(loan)] = updatedLoan\n        \n        // Update available copies\n        findBookByIsbn(loan.bookIsbn)?.let { book ->\n            val updatedBook = book.copy(availableCopies = book.availableCopies + 1)\n            books[books.indexOf(book)] = updatedBook\n        }\n        \n        return OperationResult.Success(updatedLoan)\n    }\n    \n    // Analytics using collection operations\n    fun getLibraryStats(): LibraryStats {\n        val totalBooks = books.size\n        val totalMembers = members.size\n        val activeLoans = loans.getActiveLoans().size\n        val overdueLoans = loans.getOverdueLoans().size\n        val booksByGenre = books.groupByGenre().mapValues { it.value.size }\n        val mostPopularGenre = booksByGenre.maxByOrNull { it.value }?.key\n        \n        return LibraryStats(\n            totalBooks = totalBooks,\n            totalMembers = totalMembers,\n            activeLoans = activeLoans,\n            overdueLoans = overdueLoans,\n            booksByGenre = booksByGenre,\n            mostPopularGenre = mostPopularGenre\n        )\n    }\n    \n    // Recommendation engine using when expressions and lambdas\n    fun recommendBooks(memberId: Int): List<Book> {\n        val memberLoans = loans.filter { it.memberId == memberId }\n        val borrowedGenres = memberLoans.mapNotNull { loan ->\n            findBookByIsbn(loan.bookIsbn)?.genre\n        }.distinct()\n        \n        return books.filter { book ->\n            when {\n                borrowedGenres.isEmpty() -> true // New member, show all\n                book.genre in borrowedGenres -> Random.nextDouble() > 0.3\n                else -> Random.nextDouble() > 0.7\n            }\n        }.take(5)\n    }\n    \n    // Batch operations\n    fun processOverdueNotifications(): List<OverdueNotification> {\n        return loans.getOverdueLoans().mapNotNull { loan ->\n            val member = findMemberById(loan.memberId)\n            val book = findBookByIsbn(loan.bookIsbn)\n            \n            if (member != null && book != null) {\n                OverdueNotification(\n                    memberName = member.name,\n                    memberEmail = member.email,\n                    bookTitle = book.title,\n                    daysOverdue = loan.daysOverdue,\n                    fine = calculateFine(loan.daysOverdue)\n                )\n            } else null\n        }\n    }\n    \n    private fun calculateFine(daysOverdue: Long): Double = \n        daysOverdue * 0.50 // $0.50 per day\n    \n    // Getters for testing\n    fun getAllBooks() = books.toList()\n    fun getAllMembers() = members.toList()\n    fun getAllLoans() = loans.toList()\n}\n\n// Data classes for analytics\ndata class LibraryStats(\n    val totalBooks: Int,\n    val totalMembers: Int,\n    val activeLoans: Int,\n    val overdueLoans: Int,\n    val booksByGenre: Map<Genre, Int>,\n    val mostPopularGenre: Genre?\n)\n\ndata class OverdueNotification(\n    val memberName: String,\n    val memberEmail: String,\n    val bookTitle: String,\n    val daysOverdue: Long,\n    val fine: Double\n) {\n    fun formatMessage(): String = \"\"\"\n        Dear $memberName,\n        \n        Your loan for \"$bookTitle\" is $daysOverdue days overdue.\n        Current fine: $${\n\"%.2f\".format(fine)}\n        \n        Please return the book as soon as possible.\n        \n        Thank you,\n        Library Management\n    \"\"\".trimIndent()\n}\n\nprintln(\"✓ services.kts validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "execute_code",
      "arguments": {
        "language": "kotlin",
        "filename": "main.kts",
        "save": true,
        "session_id": "kotlin-library",
        "code": "#!/usr/bin/env kotlin\n// Main script for Library Management System demonstration\n\nimport java.time.LocalDate\n\nprintln(\"=== KOTLIN LIBRARY MANAGEMENT SYSTEM DEMO ===\")\nprintln()\n\n// Initialize the library service\nval library = LibraryService()\nprintln(\"✓ Library service initialized\")\n\nprintln(\"\\n=== ADDING BOOKS TO LIBRARY ===\")\n\n// Add books using different approaches\n// 1. Using data class constructor\nval book1 = Book(\n    isbn = \"978-0-13-468599-1\",\n    title = \"Effective Kotlin\",\n    author = \"Joshua Bloch\",\n    publishedDate = LocalDate.of(2019, 10, 1),\n    genre = Genre.TECHNICAL,\n    availableCopies = 3\n)\n\n// 2. Using DSL-style builder\nval book2 = book {\n    isbn = \"978-1-61729-446-6\"\n    title = \"Kotlin in Action\"\n    author = \"Dmitry Jemerov\"\n    publishedDate = LocalDate.of(2017, 2, 1)\n    genre = Genre.TECHNICAL\n    availableCopies = 2\n}\n\n// 3. More books for variety\nval books = listOf(\n    book1,\n    book2,\n    Book(\"978-0-545-01022-1\", \"Harry Potter and the Deathly Hallows\", \"J.K. Rowling\", \n         LocalDate.of(2007, 7, 21), Genre.FANTASY, 5),\n    Book(\"978-0-7432-7356-5\", \"The Da Vinci Code\", \"Dan Brown\", \n         LocalDate.of(2003, 3, 18), Genre.MYSTERY, 4),\n    Book(\"978-0-14-044926-6\", \"Crime and Punishment\", \"Fyodor Dostoevsky\", \n         LocalDate.of(1866, 1, 1), Genre.FICTION, 2)\n)\n\n// Add books and handle results using sealed class\nbooks.forEach { book ->\n    library.addBook(book)\n        .onSuccess { println(\"✓ Added: ${it.title}\") }\n        .onError { println(\"✗ Error: $it\") }\n}\n\nprintln(\"\\n=== REGISTERING MEMBERS ===\")\n\n// Register members with different membership types\nval memberResults = listOf(\n    library.registerMember(\"Alice Johnson\", \"alice@example.com\", MembershipType.Premium),\n    library.registerMember(\"Bob Smith\", \"bob@university.edu\", MembershipType.Student),\n    library.registerMember(\"Carol White\", \"carol@email.com\", MembershipType.Regular),\n    library.registerMember(\"Invalid User\", \"not-an-email\", MembershipType.Regular)\n)\n\nmemberResults.forEach { result ->\n    when (result) {\n        is OperationResult.Success -> {\n            val member = result.data\n            println(\"✓ Registered: ${member.name} (${member.membershipType.describe()})\")\n        }\n        is OperationResult.Error -> println(\"✗ Registration failed: ${result.message}\")\n    }\n}\n\nprintln(\"\\n=== BORROWING BOOKS ===\")\n\n// Members borrow books\nval loanResults = listOf(\n    library.borrowBook(1, \"978-0-13-468599-1\"), // Alice borrows Effective Kotlin\n    library.borrowBook(1, \"978-0-545-01022-1\"), // Alice borrows Harry Potter\n    library.borrowBook(2, \"978-1-61729-446-6\"), // Bob borrows Kotlin in Action\n    library.borrowBook(3, \"978-0-7432-7356-5\"), // Carol borrows Da Vinci Code\n    library.borrowBook(3, \"978-0-14-044926-6\"), // Carol borrows Crime and Punishment\n)\n\nloanResults.forEach { result ->\n    result\n        .onSuccess { loan ->\n            val member = library.findMemberById(loan.memberId)?.name ?: \"Unknown\"\n            val book = library.findBookByIsbn(loan.bookIsbn)?.title ?: \"Unknown\"\n            println(\"✓ $member borrowed \\\"$book\\\" (Due: ${loan.dueDate.toReadableString()})\")\n        }\n        .onError { println(\"✗ Borrow failed: $it\") }\n}\n\nprintln(\"\\n=== DEMONSTRATING EXTENSION FUNCTIONS ===\")\n\nval allBooks = library.getAllBooks()\nprintln(\"\\nBooks by Genre:\")\nallBooks.groupByGenre().forEach { (genre, books) ->\n    println(\"  $genre: ${books.size} books\")\n}\n\nprintln(\"\\nTechnical Books:\")\nallBooks.filterByGenre(Genre.TECHNICAL).forEach { book ->\n    println(\"  - ${book.title} by ${book.author}\")\n}\n\nprintln(\"\\n=== LIBRARY STATISTICS ===\")\n\nval stats = library.getLibraryStats()\nprintln(\"\"\"\n📊 Library Overview:\n   Total Books: ${stats.totalBooks}\n   Total Members: ${stats.totalMembers}\n   Active Loans: ${stats.activeLoans}\n   Overdue Loans: ${stats.overdueLoans}\n   Most Popular Genre: ${stats.mostPopularGenre ?: \"N/A\"}\n\"\"\")\n\nprintln(\"=== BOOK RECOMMENDATIONS ===\")\n\n// Get recommendations for Alice (member ID 1)\nprintln(\"\\nRecommendations for Alice:\")\nlibrary.recommendBooks(1).forEach { book ->\n    println(\"  📖 ${book.title} (${book.genre})\")\n}\n\nprintln(\"\\n=== RETURNING BOOKS ===\")\n\n// Return some books\nlibrary.returnBook(1)\n    .onSuccess { println(\"✓ Book returned successfully (Loan ID: ${it.id})\") }\n    .onError { println(\"✗ Return failed: $it\") }\n\nprintln(\"\\n=== DEMONSTRATING KOTLIN FEATURES ===\")\n\n// Null safety\nval maybeBook: Book? = library.findBookByIsbn(\"123-456-789\")\nprintln(\"\\nNull safety demo:\")\nprintln(\"Book found: ${maybeBook?.title ?: \"No book with that ISBN\"}\")\n\n// When expression\nval genre = Genre.FANTASY\nval genreDescription = when (genre) {\n    Genre.FICTION, Genre.FANTASY -> \"Imaginative literature\"\n    Genre.TECHNICAL, Genre.SCIENCE -> \"Educational content\"\n    Genre.MYSTERY, Genre.THRILLER -> \"Suspenseful stories\"\n    else -> \"Various genres\"\n}\nprintln(\"\\nWhen expression: $genre is $genreDescription\")\n\n// String templates and raw strings\nval libraryName = \"City Central Library\"\nval announcement = \"\"\"\n    |📚 Welcome to $libraryName!\n    |   \n    |   We currently have ${stats.totalBooks} books available\n    |   Serving ${stats.totalMembers} happy members\n    |   \n    |   Library Hours:\n    |   Mon-Fri: 9:00 AM - 8:00 PM\n    |   Sat-Sun: 10:00 AM - 6:00 PM\n\"\"\".trimMargin()\n\nprintln(\"\\nString template demo:\")\nprintln(announcement)\n\n// Lambda with receiver (similar to 'with' function)\nval bookSummary = with(book1) {\n    \"\"\"\n    Book Details:\n    - Title: $title\n    - Author: $author  \n    - ISBN: $isbn\n    - Available: $availableCopies copies\n    \"\"\".trimIndent()\n}\nprintln(\"\\nLambda with receiver:\")\nprintln(bookSummary)\n\n// Collection operations chaining\nprintln(\"\\nCollection operations demo:\")\nval recentTechnicalBooks = allBooks\n    .filter { it.genre == Genre.TECHNICAL }\n    .filter { it.publishedDate.isAfter(LocalDate.of(2015, 1, 1)) }\n    .sortedByDescending { it.publishedDate }\n    .map { \"${it.title} (${it.publishedDate.year})\" }\n\nprintln(\"Recent technical books:\")\nrecentTechnicalBooks.forEach { println(\"  - $it\") }\n\nprintln(\"\\n✅ Kotlin Library Management System demo completed!\")\nprintln(\"\\n🎯 Key Kotlin features demonstrated:\")\nprintln(\"   - Data classes and sealed classes\")\nprintln(\"   - Extension functions\")\nprintln(\"   - Null safety\")\nprintln(\"   - Lambda expressions\")\nprintln(\"   - Collection operations\")\nprintln(\"   - String templates\")\nprintln(\"   - When expressions\")\nprintln(\"   - Companion objects\")\nprintln(\"\\n🔄 All files persist within this container session\")\nprintln(\"🗑️  Files will be cleaned up when container restarts\")\nprintln(\"🔒 Host system remains completely isolated\")"
      }
    }
  }
]