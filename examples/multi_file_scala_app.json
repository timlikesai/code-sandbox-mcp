[
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "scala",
        "filename": "models.scala",
        "save": true,
        "session_id": "scala-crypto-trading",
        "code": "// Case classes and traits for cryptocurrency trading system\n\nimport java.time.Instant\nimport scala.util.{Try, Success, Failure}\n\n// Core domain models\nsealed trait Currency\ncase object USD extends Currency\ncase object EUR extends Currency\ncase object GBP extends Currency\n\nsealed trait CryptoCurrency\ncase object BTC extends CryptoCurrency\ncase object ETH extends CryptoCurrency\ncase object ADA extends CryptoCurrency\ncase object SOL extends CryptoCurrency\n\n// Trading models\ncase class Price(amount: BigDecimal, currency: Currency) {\n  def *(multiplier: BigDecimal): Price = copy(amount = amount * multiplier)\n  def +(other: Price): Price = {\n    require(currency == other.currency, \"Cannot add prices with different currencies\")\n    copy(amount = amount + other.amount)\n  }\n}\n\ncase class CryptoAsset(\n  symbol: CryptoCurrency,\n  name: String,\n  currentPrice: Price,\n  marketCap: Option[BigDecimal] = None,\n  volume24h: Option[BigDecimal] = None\n)\n\nsealed trait OrderType\ncase object MarketOrder extends OrderType\ncase class LimitOrder(limitPrice: Price) extends OrderType\ncase class StopLossOrder(stopPrice: Price) extends OrderType\n\nsealed trait OrderSide\ncase object Buy extends OrderSide\ncase object Sell extends OrderSide\n\nsealed trait OrderStatus\ncase object Pending extends OrderStatus\ncase object Filled extends OrderStatus\ncase object PartiallyFilled extends OrderStatus\ncase object Cancelled extends OrderStatus\ncase object Failed extends OrderStatus\n\ncase class Order(\n  id: String,\n  crypto: CryptoCurrency,\n  side: OrderSide,\n  orderType: OrderType,\n  quantity: BigDecimal,\n  status: OrderStatus,\n  createdAt: Instant,\n  filledAt: Option[Instant] = None,\n  executionPrice: Option[Price] = None\n)\n\ncase class Portfolio(\n  id: String,\n  userId: String,\n  holdings: Map[CryptoCurrency, BigDecimal],\n  fiatBalance: Map[Currency, BigDecimal],\n  totalValue: Option[Price] = None\n) {\n  def addHolding(crypto: CryptoCurrency, amount: BigDecimal): Portfolio =\n    copy(holdings = holdings + (crypto -> (holdings.getOrElse(crypto, BigDecimal(0)) + amount)))\n  \n  def removeHolding(crypto: CryptoCurrency, amount: BigDecimal): Either[String, Portfolio] = {\n    val current = holdings.getOrElse(crypto, BigDecimal(0))\n    if (current >= amount)\n      Right(copy(holdings = holdings + (crypto -> (current - amount))))\n    else\n      Left(s\"Insufficient $crypto balance: $current < $amount\")\n  }\n}\n\ncase class Transaction(\n  id: String,\n  portfolioId: String,\n  orderId: String,\n  crypto: CryptoCurrency,\n  side: OrderSide,\n  quantity: BigDecimal,\n  price: Price,\n  fee: Price,\n  timestamp: Instant\n)\n\n// Risk management models\ncase class RiskProfile(\n  maxPositionSize: BigDecimal,\n  maxDailyLoss: Price,\n  stopLossPercentage: BigDecimal\n)\n\ncase class Alert(\n  id: String,\n  crypto: CryptoCurrency,\n  condition: String,\n  threshold: Price,\n  active: Boolean = true\n)\n\nprintln(\"‚úì models.scala validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "scala",
        "filename": "utils.scala",
        "save": true,
        "session_id": "scala-crypto-trading",
        "code": "// Functional utilities and implicit conversions\n\nimport scala.concurrent.{Future, ExecutionContext}\nimport scala.util.{Try, Success, Failure}\nimport java.time.{Instant, Duration}\nimport scala.language.implicitConversions\n\n// Import models (assumes they're available in session)\nimport models._\n\nobject CryptoUtils {\n  // Type aliases for readability\n  type CryptoAmount = BigDecimal\n  type FiatAmount = BigDecimal\n  type OrderResult = Either[String, Order]\n  type PortfolioResult = Either[String, Portfolio]\n  \n  // Implicit conversions and enrichments\n  implicit class RichBigDecimal(val value: BigDecimal) extends AnyVal {\n    def toCrypto: CryptoAmount = value\n    def toFiat: FiatAmount = value\n    def roundTo(decimals: Int): BigDecimal = \n      value.setScale(decimals, BigDecimal.RoundingMode.HALF_UP)\n  }\n  \n  implicit class RichPrice(val price: Price) extends AnyVal {\n    def isAbove(other: Price): Boolean = {\n      require(price.currency == other.currency, \"Cannot compare prices with different currencies\")\n      price.amount > other.amount\n    }\n    \n    def isBelow(other: Price): Boolean = {\n      require(price.currency == other.currency, \"Cannot compare prices with different currencies\")\n      price.amount < other.amount\n    }\n    \n    def percentageChange(from: Price): BigDecimal = {\n      require(price.currency == from.currency, \"Cannot calculate percentage change with different currencies\")\n      ((price.amount - from.amount) / from.amount * 100).roundTo(2)\n    }\n  }\n  \n  // Higher-order functions for trading strategies\n  def applyTradingStrategy[T](strategy: => T)(fallback: => T)(implicit ec: ExecutionContext): Future[T] = {\n    Future {\n      Try(strategy) match {\n        case Success(result) => result\n        case Failure(_) => fallback\n      }\n    }\n  }\n  \n  // Partial functions for order validation\n  val validateMarketOrder: PartialFunction[Order, OrderResult] = {\n    case order @ Order(_, _, _, MarketOrder, quantity, _, _, _, _) if quantity > 0 =>\n      Right(order)\n    case order @ Order(_, _, _, MarketOrder, _, _, _, _, _) =>\n      Left(\"Market order quantity must be positive\")\n  }\n  \n  val validateLimitOrder: PartialFunction[Order, OrderResult] = {\n    case order @ Order(_, _, _, LimitOrder(price), quantity, _, _, _, _) if quantity > 0 && price.amount > 0 =>\n      Right(order)\n    case Order(_, _, _, LimitOrder(_), _, _, _, _, _) =>\n      Left(\"Limit order must have positive quantity and price\")\n  }\n  \n  // Compose validators\n  val validateOrder: PartialFunction[Order, OrderResult] = \n    validateMarketOrder orElse validateLimitOrder orElse {\n      case _ => Left(\"Unsupported order type\")\n    }\n  \n  // Functional combinators\n  def sequence[A](list: List[Option[A]]): Option[List[A]] = \n    list.foldRight(Option(List.empty[A])) { (elem, acc) =>\n      for {\n        list <- acc\n        value <- elem\n      } yield value :: list\n    }\n  \n  def traverse[A, B](list: List[A])(f: A => Option[B]): Option[List[B]] =\n    sequence(list.map(f))\n  \n  // Time utilities\n  implicit class RichInstant(val instant: Instant) extends AnyVal {\n    def isOlderThan(duration: Duration): Boolean =\n      instant.plus(duration).isBefore(Instant.now())\n    \n    def durationSince(other: Instant): Duration =\n      Duration.between(other, instant)\n  }\n  \n  // Monadic operations for Either\n  implicit class EitherOps[E, A](val either: Either[E, A]) extends AnyVal {\n    def flatMapRight[B](f: A => Either[E, B]): Either[E, B] = either.flatMap(f)\n    \n    def mapLeft[F](f: E => F): Either[F, A] = either match {\n      case Left(e) => Left(f(e))\n      case Right(a) => Right(a)\n    }\n  }\n  \n  // Smart constructors\n  object SmartConstructors {\n    def createOrder(\n      crypto: CryptoCurrency,\n      side: OrderSide,\n      orderType: OrderType,\n      quantity: BigDecimal\n    ): Either[String, Order] = {\n      if (quantity <= 0) Left(\"Order quantity must be positive\")\n      else Right(Order(\n        id = java.util.UUID.randomUUID().toString,\n        crypto = crypto,\n        side = side,\n        orderType = orderType,\n        quantity = quantity,\n        status = Pending,\n        createdAt = Instant.now()\n      ))\n    }\n    \n    def createPortfolio(userId: String): Portfolio = Portfolio(\n      id = java.util.UUID.randomUUID().toString,\n      userId = userId,\n      holdings = Map.empty,\n      fiatBalance = Map(USD -> BigDecimal(10000)) // Start with $10,000\n    )\n  }\n}\n\n// Configuration using implicit parameters\nobject Config {\n  implicit val defaultCurrency: Currency = USD\n  implicit val defaultExecutionContext: ExecutionContext = scala.concurrent.ExecutionContext.global\n  \n  case class TradingConfig(\n    maxSlippage: BigDecimal = 0.02, // 2%\n    defaultFee: BigDecimal = 0.001,  // 0.1%\n    minOrderSize: Map[CryptoCurrency, BigDecimal] = Map(\n      BTC -> 0.0001,\n      ETH -> 0.001,\n      ADA -> 1.0,\n      SOL -> 0.1\n    )\n  )\n  \n  implicit val tradingConfig: TradingConfig = TradingConfig()\n}\n\nprintln(\"‚úì utils.scala validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "scala",
        "filename": "services.scala",
        "save": true,
        "session_id": "scala-crypto-trading",
        "code": "// Service layer with pattern matching and functional programming\n\nimport scala.concurrent.{Future, ExecutionContext}\nimport scala.util.{Try, Success, Failure, Random}\nimport java.time.Instant\nimport scala.collection.immutable._\n\n// Import models and utils (assumes they're available in session)\nimport models._\nimport utils.CryptoUtils._\nimport utils.Config._\n\n// Market data service\nobject MarketDataService {\n  // Simulated market data\n  private val baseePrices = Map(\n    BTC -> BigDecimal(45000),\n    ETH -> BigDecimal(3200),\n    ADA -> BigDecimal(0.45),\n    SOL -> BigDecimal(95)\n  )\n  \n  def getCurrentPrice(crypto: CryptoCurrency)(implicit currency: Currency): Price = {\n    val basePrice = baseePrices.getOrElse(crypto, BigDecimal(0))\n    val volatility = Random.nextDouble() * 0.1 - 0.05 // ¬±5% volatility\n    Price(basePrice * (1 + volatility), currency)\n  }\n  \n  def getPriceHistory(crypto: CryptoCurrency, hours: Int): List[(Instant, Price)] = {\n    val now = Instant.now()\n    (0 until hours).map { h =>\n      val time = now.minusSeconds(h * 3600)\n      val price = getCurrentPrice(crypto)\n      (time, price)\n    }.toList.reverse\n  }\n  \n  // Pattern matching for price alerts\n  def checkPriceAlert(alert: Alert, currentPrice: Price): Option[String] = alert match {\n    case Alert(_, crypto, \"above\", threshold, true) if currentPrice.isAbove(threshold) =>\n      Some(s\"$crypto price ($${currentPrice.amount}) is above threshold ($${threshold.amount})\")\n    case Alert(_, crypto, \"below\", threshold, true) if currentPrice.isBelow(threshold) =>\n      Some(s\"$crypto price ($${currentPrice.amount}) is below threshold ($${threshold.amount})\")\n    case _ => None\n  }\n}\n\n// Trading service with advanced pattern matching\nclass TradingService(implicit ec: ExecutionContext, config: TradingConfig) {\n  \n  def executeOrder(order: Order, portfolio: Portfolio): Future[Either[String, (Order, Portfolio, Transaction)]] = {\n    Future {\n      validateOrder(order) match {\n        case Left(error) => Left(error)\n        case Right(validOrder) => processOrder(validOrder, portfolio)\n      }\n    }\n  }\n  \n  private def processOrder(order: Order, portfolio: Portfolio): Either[String, (Order, Portfolio, Transaction)] = {\n    val currentPrice = MarketDataService.getCurrentPrice(order.crypto)\n    \n    (order.side, order.orderType) match {\n      case (Buy, MarketOrder) => executeBuyOrder(order, portfolio, currentPrice)\n      case (Sell, MarketOrder) => executeSellOrder(order, portfolio, currentPrice)\n      case (Buy, LimitOrder(limit)) if currentPrice.isBelow(limit) => \n        executeBuyOrder(order, portfolio, currentPrice)\n      case (Sell, LimitOrder(limit)) if currentPrice.isAbove(limit) => \n        executeSellOrder(order, portfolio, currentPrice)\n      case (_, LimitOrder(_)) => \n        Left(\"Limit order cannot be executed at current price\")\n      case (_, StopLossOrder(stopPrice)) if currentPrice.isBelow(stopPrice) =>\n        executeSellOrder(order, portfolio, currentPrice)\n      case _ => \n        Left(\"Order conditions not met\")\n    }\n  }\n  \n  private def executeBuyOrder(order: Order, portfolio: Portfolio, price: Price): Either[String, (Order, Portfolio, Transaction)] = {\n    val totalCost = price * order.quantity\n    val fee = totalCost * config.defaultFee\n    val totalWithFee = totalCost + fee\n    \n    portfolio.fiatBalance.get(price.currency) match {\n      case Some(balance) if balance >= totalWithFee.amount =>\n        val updatedPortfolio = portfolio.copy(\n          holdings = portfolio.addHolding(order.crypto, order.quantity).holdings,\n          fiatBalance = portfolio.fiatBalance + (price.currency -> (balance - totalWithFee.amount))\n        )\n        val executedOrder = order.copy(\n          status = Filled,\n          filledAt = Some(Instant.now()),\n          executionPrice = Some(price)\n        )\n        val transaction = createTransaction(executedOrder, portfolio.id, price, fee)\n        Right((executedOrder, updatedPortfolio, transaction))\n        \n      case Some(_) => Left(\"Insufficient fiat balance\")\n      case None => Left(s\"No ${price.currency} balance available\")\n    }\n  }\n  \n  private def executeSellOrder(order: Order, portfolio: Portfolio, price: Price): Either[String, (Order, Portfolio, Transaction)] = {\n    portfolio.removeHolding(order.crypto, order.quantity) match {\n      case Left(error) => Left(error)\n      case Right(portfolioAfterRemoval) =>\n        val totalRevenue = price * order.quantity\n        val fee = totalRevenue * config.defaultFee\n        val netRevenue = totalRevenue + Price(-fee.amount, price.currency)\n        \n        val updatedPortfolio = portfolioAfterRemoval.copy(\n          fiatBalance = portfolioAfterRemoval.fiatBalance + \n            (price.currency -> (portfolioAfterRemoval.fiatBalance.getOrElse(price.currency, BigDecimal(0)) + netRevenue.amount))\n        )\n        \n        val executedOrder = order.copy(\n          status = Filled,\n          filledAt = Some(Instant.now()),\n          executionPrice = Some(price)\n        )\n        \n        val transaction = createTransaction(executedOrder, portfolio.id, price, fee)\n        Right((executedOrder, updatedPortfolio, transaction))\n    }\n  }\n  \n  private def createTransaction(order: Order, portfolioId: String, price: Price, fee: Price): Transaction =\n    Transaction(\n      id = java.util.UUID.randomUUID().toString,\n      portfolioId = portfolioId,\n      orderId = order.id,\n      crypto = order.crypto,\n      side = order.side,\n      quantity = order.quantity,\n      price = price,\n      fee = fee,\n      timestamp = Instant.now()\n    )\n}\n\n// Portfolio analysis service using functional composition\nobject PortfolioAnalysisService {\n  \n  def calculatePortfolioValue(portfolio: Portfolio)(implicit currency: Currency): Price = {\n    val cryptoValue = portfolio.holdings.foldLeft(BigDecimal(0)) { case (total, (crypto, amount)) =>\n      total + (MarketDataService.getCurrentPrice(crypto).amount * amount)\n    }\n    val fiatValue = portfolio.fiatBalance.getOrElse(currency, BigDecimal(0))\n    Price(cryptoValue + fiatValue, currency)\n  }\n  \n  def getTopHoldings(portfolio: Portfolio, n: Int): List[(CryptoCurrency, BigDecimal, Price)] = {\n    portfolio.holdings.toList\n      .map { case (crypto, amount) => \n        val value = MarketDataService.getCurrentPrice(crypto) * amount\n        (crypto, amount, value)\n      }\n      .sortBy(-_._3.amount)\n      .take(n)\n  }\n  \n  // For comprehension example\n  def analyzePortfolioRisk(portfolio: Portfolio, riskProfile: RiskProfile): Either[String, String] = {\n    for {\n      totalValue <- Right(calculatePortfolioValue(portfolio))\n      largestPosition <- portfolio.holdings.toList match {\n        case Nil => Left(\"Portfolio is empty\")\n        case holdings => Right(holdings.map { case (crypto, amount) =>\n          MarketDataService.getCurrentPrice(crypto) * amount\n        }.maxBy(_.amount))\n      }\n      riskAssessment <- if (largestPosition.amount / totalValue.amount > riskProfile.maxPositionSize)\n        Left(s\"Position size exceeds risk limit: ${(largestPosition.amount / totalValue.amount * 100).roundTo(2)}%\")\n      else\n        Right(\"Portfolio risk within acceptable limits\")\n    } yield riskAssessment\n  }\n  \n  // Using pattern matching with collections\n  def generatePortfolioReport(portfolio: Portfolio): String = {\n    val totalValue = calculatePortfolioValue(portfolio)\n    val holdings = getTopHoldings(portfolio, 10)\n    \n    s\"\"\"Portfolio Report\n       |================\n       |Portfolio ID: ${portfolio.id}\n       |Total Value: $${totalValue.amount.roundTo(2)} ${totalValue.currency}\n       |\n       |Holdings:\n       |${holdings.map { case (crypto, amount, value) =>\n         s\"  $crypto: $amount units ($${value.amount.roundTo(2)})\"\n       }.mkString(\"\\n\")}\n       |\n       |Fiat Balances:\n       |${portfolio.fiatBalance.map { case (currency, amount) =>\n         s\"  $currency: $${amount.roundTo(2)}\"\n       }.mkString(\"\\n\")}\n    \"\"\".stripMargin\n  }\n}\n\n// Strategy service using higher-order functions\nobject TradingStrategyService {\n  \n  type Strategy = (CryptoCurrency, Portfolio) => Option[Order]\n  \n  // Dollar-cost averaging strategy\n  val dollarCostAveraging: (BigDecimal, Currency) => Strategy = (amount, currency) => (crypto, portfolio) => {\n    portfolio.fiatBalance.get(currency).filter(_ >= amount).map { _ =>\n      val price = MarketDataService.getCurrentPrice(crypto)\n      val quantity = (amount / price.amount).roundTo(8)\n      SmartConstructors.createOrder(crypto, Buy, MarketOrder, quantity).toOption\n    }.flatten\n  }\n  \n  // Momentum trading strategy\n  val momentumTrading: (BigDecimal) => Strategy = (threshold) => (crypto, portfolio) => {\n    val history = MarketDataService.getPriceHistory(crypto, 24)\n    val momentum = history match {\n      case first :: _ :: last :: Nil => \n        last._2.percentageChange(first._2)\n      case _ => BigDecimal(0)\n    }\n    \n    if (momentum > threshold) {\n      SmartConstructors.createOrder(crypto, Buy, MarketOrder, 0.1).toOption\n    } else if (momentum < -threshold) {\n      portfolio.holdings.get(crypto).filter(_ > 0).flatMap { holding =>\n        SmartConstructors.createOrder(crypto, Sell, MarketOrder, holding * 0.1).toOption\n      }\n    } else None\n  }\n  \n  // Combine strategies\n  def combineStrategies(strategies: Strategy*): Strategy = (crypto, portfolio) => {\n    strategies.view.flatMap(_.apply(crypto, portfolio)).headOption\n  }\n  \n  // Apply strategy with logging\n  def applyStrategyWithLogging(strategy: Strategy)(crypto: CryptoCurrency, portfolio: Portfolio): Option[Order] = {\n    val result = strategy(crypto, portfolio)\n    result.foreach { order =>\n      println(s\"Strategy generated order: ${order.side} ${order.quantity} $crypto\")\n    }\n    result\n  }\n}\n\nprintln(\"‚úì services.scala validated and saved\")"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "execute_code",
      "arguments": {
        "language": "scala",
        "filename": "Main.scala",
        "save": true,
        "session_id": "scala-crypto-trading",
        "code": "// Main application demonstrating all Scala features\n\nimport scala.concurrent.{Await, Future}\nimport scala.concurrent.duration._\nimport scala.util.{Try, Success, Failure}\nimport java.time.Instant\n\n// Import all modules (assumes they're available in session)\nimport models._\nimport utils.CryptoUtils._\nimport utils.Config._\nimport services._\n\nobject Main extends App {\n  println(\"=== CRYPTOCURRENCY TRADING SYSTEM - SCALA DEMO ===\")\n  println()\n  \n  // Initialize services\n  implicit val ec = scala.concurrent.ExecutionContext.global\n  val tradingService = new TradingService()\n  \n  println(\"=== DEMONSTRATING CASE CLASSES AND TRAITS ===\")\n  \n  // Create crypto assets\n  val bitcoin = CryptoAsset(\n    symbol = BTC,\n    name = \"Bitcoin\",\n    currentPrice = MarketDataService.getCurrentPrice(BTC),\n    marketCap = Some(BigDecimal(900000000000L)),\n    volume24h = Some(BigDecimal(25000000000L))\n  )\n  \n  val ethereum = CryptoAsset(\n    symbol = ETH,\n    name = \"Ethereum\",\n    currentPrice = MarketDataService.getCurrentPrice(ETH),\n    marketCap = Some(BigDecimal(380000000000L)),\n    volume24h = Some(BigDecimal(15000000000L))\n  )\n  \n  println(s\"Bitcoin: $bitcoin\")\n  println(s\"Ethereum: $ethereum\")\n  \n  println(\"\\n=== DEMONSTRATING PATTERN MATCHING ===\")\n  \n  // Pattern matching on sealed traits\n  def describeCrypto(crypto: CryptoCurrency): String = crypto match {\n    case BTC => \"The original cryptocurrency\"\n    case ETH => \"Smart contract platform\"\n    case ADA => \"Proof-of-stake blockchain\"\n    case SOL => \"High-performance blockchain\"\n  }\n  \n  List(BTC, ETH, ADA, SOL).foreach { crypto =>\n    println(s\"$crypto: ${describeCrypto(crypto)}\")\n  }\n  \n  println(\"\\n=== DEMONSTRATING OPTION/EITHER TYPES ===\")\n  \n  // Create portfolio and orders\n  val portfolio = SmartConstructors.createPortfolio(\"user123\")\n  println(s\"Created portfolio: ${portfolio.id}\")\n  \n  // Try creating valid and invalid orders\n  val validOrder = SmartConstructors.createOrder(BTC, Buy, MarketOrder, 0.01)\n  val invalidOrder = SmartConstructors.createOrder(ETH, Sell, MarketOrder, -1)\n  \n  println(s\"Valid order result: $validOrder\")\n  println(s\"Invalid order result: $invalidOrder\")\n  \n  println(\"\\n=== DEMONSTRATING IMPLICIT CONVERSIONS ===\")\n  \n  // Using implicit conversions\n  val btcPrice = MarketDataService.getCurrentPrice(BTC)\n  val ethPrice = MarketDataService.getCurrentPrice(ETH)\n  \n  println(s\"BTC price: $${btcPrice.amount.roundTo(2)}\")\n  println(s\"ETH price: $${ethPrice.amount.roundTo(2)}\")\n  println(s\"BTC is ${if (btcPrice.isAbove(Price(40000, USD))) \"above\" else \"below\"} $40,000\")\n  println(s\"ETH change from $3000: ${ethPrice.percentageChange(Price(3000, USD))}%\")\n  \n  println(\"\\n=== DEMONSTRATING HIGHER-ORDER FUNCTIONS ===\")\n  \n  // Apply trading strategies\n  val dcaStrategy = TradingStrategyService.dollarCostAveraging(100, USD)\n  val momentumStrategy = TradingStrategyService.momentumTrading(5)\n  val combinedStrategy = TradingStrategyService.combineStrategies(dcaStrategy, momentumStrategy)\n  \n  val strategyOrder = TradingStrategyService.applyStrategyWithLogging(combinedStrategy)(BTC, portfolio)\n  println(s\"Strategy result: ${strategyOrder.map(o => s\"${o.side} ${o.quantity} ${o.crypto}\").getOrElse(\"No action\")}\")\n  \n  println(\"\\n=== DEMONSTRATING FOR COMPREHENSIONS ===\")\n  \n  // Execute a series of trades\n  val tradingResult = for {\n    order1 <- SmartConstructors.createOrder(BTC, Buy, MarketOrder, 0.005)\n    order2 <- SmartConstructors.createOrder(ETH, Buy, MarketOrder, 0.1)\n    order3 <- SmartConstructors.createOrder(ADA, Buy, MarketOrder, 100)\n  } yield List(order1, order2, order3)\n  \n  tradingResult match {\n    case Right(orders) =>\n      println(s\"Created ${orders.length} orders successfully\")\n      \n      // Execute orders asynchronously\n      val executionFutures = orders.map { order =>\n        tradingService.executeOrder(order, portfolio)\n      }\n      \n      val results = Await.result(Future.sequence(executionFutures), 5.seconds)\n      \n      results.foreach {\n        case Right((order, _, _)) => \n          println(s\"‚úì Executed: ${order.side} ${order.quantity} ${order.crypto} at $${order.executionPrice.map(_.amount.roundTo(2)).getOrElse(\"N/A\")}\")\n        case Left(error) => \n          println(s\"‚úó Failed: $error\")\n      }\n      \n      // Update portfolio based on successful trades\n      val finalPortfolio = results.foldLeft(portfolio) {\n        case (p, Right((_, updatedPortfolio, _))) => updatedPortfolio\n        case (p, Left(_)) => p\n      }\n      \n      println(s\"\\nFinal portfolio value: $${PortfolioAnalysisService.calculatePortfolioValue(finalPortfolio).amount.roundTo(2)}\")\n      \n    case Left(error) => println(s\"Failed to create orders: $error\")\n  }\n  \n  println(\"\\n=== DEMONSTRATING PARTIAL FUNCTIONS ===\")\n  \n  // Define price alert handlers\n  val alertHandlers: PartialFunction[(Alert, Price), Unit] = {\n    case (alert @ Alert(_, crypto, \"above\", threshold, true), price) if price.isAbove(threshold) =>\n      println(s\"üîî ALERT: $crypto is above $${threshold.amount} (current: $${price.amount.roundTo(2)})\")\n    case (alert @ Alert(_, crypto, \"below\", threshold, true), price) if price.isBelow(threshold) =>\n      println(s\"üîî ALERT: $crypto is below $${threshold.amount} (current: $${price.amount.roundTo(2)})\")\n  }\n  \n  // Create and check alerts\n  val alerts = List(\n    Alert(\"1\", BTC, \"above\", Price(50000, USD)),\n    Alert(\"2\", ETH, \"below\", Price(3000, USD)),\n    Alert(\"3\", ADA, \"above\", Price(0.50, USD))\n  )\n  \n  alerts.foreach { alert =>\n    val currentPrice = MarketDataService.getCurrentPrice(alert.crypto)\n    if (alertHandlers.isDefinedAt((alert, currentPrice))) {\n      alertHandlers((alert, currentPrice))\n    }\n  }\n  \n  println(\"\\n=== DEMONSTRATING COLLECTIONS API ===\")\n  \n  // Analyze portfolio holdings\n  val samplePortfolio = Portfolio(\n    id = \"sample\",\n    userId = \"demo\",\n    holdings = Map(\n      BTC -> 0.5,\n      ETH -> 2.0,\n      ADA -> 1000.0,\n      SOL -> 10.0\n    ),\n    fiatBalance = Map(USD -> 5000)\n  )\n  \n  // Use various collection operations\n  val topHoldings = PortfolioAnalysisService.getTopHoldings(samplePortfolio, 3)\n  println(\"\\nTop 3 holdings by value:\")\n  topHoldings.zipWithIndex.foreach { case ((crypto, amount, value), index) =>\n    println(s\"${index + 1}. $crypto: $amount units ($${value.amount.roundTo(2)})\")\n  }\n  \n  // Calculate statistics\n  val values = samplePortfolio.holdings.map { case (crypto, amount) =>\n    MarketDataService.getCurrentPrice(crypto).amount * amount\n  }\n  \n  val stats = if (values.nonEmpty) {\n    val total = values.sum\n    val average = total / values.size\n    val max = values.max\n    val min = values.min\n    \n    s\"\"\"Portfolio Statistics:\n       |  Total crypto value: $${total.roundTo(2)}\n       |  Average position: $${average.roundTo(2)}\n       |  Largest position: $${max.roundTo(2)}\n       |  Smallest position: $${min.roundTo(2)}\"\"\".stripMargin\n  } else \"No holdings\"\n  \n  println(s\"\\n$stats\")\n  \n  println(\"\\n=== RISK ANALYSIS DEMONSTRATION ===\")\n  \n  val riskProfile = RiskProfile(\n    maxPositionSize = 0.3, // 30% max position\n    maxDailyLoss = Price(1000, USD),\n    stopLossPercentage = 5\n  )\n  \n  PortfolioAnalysisService.analyzePortfolioRisk(samplePortfolio, riskProfile) match {\n    case Right(assessment) => println(s\"‚úì Risk Assessment: $assessment\")\n    case Left(warning) => println(s\"‚ö†Ô∏è  Risk Warning: $warning\")\n  }\n  \n  println(\"\\n=== FUNCTIONAL ERROR HANDLING ===\")\n  \n  // Chain operations with error handling\n  val complexOperation = for {\n    btcOrder <- SmartConstructors.createOrder(BTC, Sell, MarketOrder, 0.1)\n    _ <- if (samplePortfolio.holdings.getOrElse(BTC, BigDecimal(0)) >= btcOrder.quantity)\n           Right(())\n         else\n           Left(\"Insufficient BTC balance\")\n    ethOrder <- SmartConstructors.createOrder(ETH, Buy, LimitOrder(Price(3000, USD)), 1.0)\n    _ <- if (samplePortfolio.fiatBalance.getOrElse(USD, BigDecimal(0)) >= 3000)\n           Right(())\n         else\n           Left(\"Insufficient USD balance\")\n  } yield (btcOrder, ethOrder)\n  \n  complexOperation match {\n    case Right((sellOrder, buyOrder)) =>\n      println(s\"Complex operation successful:\")\n      println(s\"  - Sell ${sellOrder.quantity} ${sellOrder.crypto}\")\n      println(s\"  - Buy ${buyOrder.quantity} ${buyOrder.crypto}\")\n    case Left(error) =>\n      println(s\"Complex operation failed: $error\")\n  }\n  \n  println(\"\\n=== PERFORMANCE METRICS ===\")\n  \n  // Measure execution time using higher-order functions\n  def measureTime[T](operation: => T): (T, Long) = {\n    val start = System.currentTimeMillis()\n    val result = operation\n    val duration = System.currentTimeMillis() - start\n    (result, duration)\n  }\n  \n  val (report, time) = measureTime {\n    PortfolioAnalysisService.generatePortfolioReport(samplePortfolio)\n  }\n  \n  println(report)\n  println(s\"\\nReport generated in ${time}ms\")\n  \n  println(\"\\n=== ADVANCED TYPE SYSTEM FEATURES ===\")\n  \n  // Demonstrate type aliases and variance\n  type PriceHistory = List[(Instant, Price)]\n  type TradingPair = (CryptoCurrency, Currency)\n  type OrderBook = Map[TradingPair, List[Order]]\n  \n  val tradingPairs: List[TradingPair] = List(\n    (BTC, USD),\n    (ETH, USD),\n    (BTC, EUR)\n  )\n  \n  println(\"Available trading pairs:\")\n  tradingPairs.foreach { case (crypto, fiat) =>\n    println(s\"  $crypto/$fiat\")\n  }\n  \n  println(\"\\n‚úÖ Cryptocurrency Trading System Demo Complete!\")\n  println(\"\\nüìä Key Scala Features Demonstrated:\")\n  println(\"  ‚Ä¢ Case classes and sealed traits for domain modeling\")\n  println(\"  ‚Ä¢ Pattern matching for control flow\")\n  println(\"  ‚Ä¢ Option/Either for safe error handling\")\n  println(\"  ‚Ä¢ Implicit conversions and parameters\")\n  println(\"  ‚Ä¢ Higher-order functions and function composition\")\n  println(\"  ‚Ä¢ For comprehensions for monadic operations\")\n  println(\"  ‚Ä¢ Partial functions for conditional logic\")\n  println(\"  ‚Ä¢ Rich collections API with functional transformations\")\n  println(\"\\nüîÑ All files persist within this container session\")\n  println(\"üóëÔ∏è  Files will be cleaned up when container restarts\")\n  println(\"üîí Host system remains completely isolated\")\n}"
      }
    }
  }
]