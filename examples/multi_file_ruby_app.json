[
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "ruby",
        "filename": "mixins.rb",
        "save": true,
        "session_id": "ruby-blog",
        "code": "# Mixins and modules for our Ruby blog application\n\n# Module for timestamping functionality\nmodule Timestampable\n  def self.included(base)\n    base.extend(ClassMethods)\n    base.class_eval do\n      attr_accessor :created_at, :updated_at\n    end\n  end\n  \n  module ClassMethods\n    def with_timestamps\n      puts \"#{self.name} includes timestamp tracking\"\n    end\n  end\n  \n  def touch\n    @updated_at = Time.now\n  end\n  \n  def age_in_seconds\n    return 0 unless @created_at\n    Time.now - @created_at\n  end\nend\n\n# Module for validation functionality\nmodule Validatable\n  def self.included(base)\n    base.extend(ClassMethods)\n  end\n  \n  module ClassMethods\n    def validate(field, &block)\n      validations[field] = block\n    end\n    \n    def validations\n      @validations ||= {}\n    end\n  end\n  \n  def valid?\n    errors.clear\n    self.class.validations.each do |field, validation|\n      value = instance_variable_get(\"@#{field}\")\n      error = validation.call(value)\n      errors[field] = error if error\n    end\n    errors.empty?\n  end\n  \n  def errors\n    @errors ||= {}\n  end\nend\n\n# Module for serialization\nmodule Serializable\n  def to_hash\n    instance_variables.each_with_object({}) do |var, hash|\n      key = var.to_s.delete('@').to_sym\n      value = instance_variable_get(var)\n      hash[key] = serialize_value(value)\n    end\n  end\n  \n  def to_json\n    require 'json'\n    to_hash.to_json\n  end\n  \n  private\n  \n  def serialize_value(value)\n    case value\n    when Array\n      value.map { |v| v.respond_to?(:to_hash) ? v.to_hash : v }\n    when Time\n      value.iso8601\n    else\n      value.respond_to?(:to_hash) ? value.to_hash : value\n    end\n  end\nend\n\n# Module for ID generation\nmodule Identifiable\n  def self.included(base)\n    base.extend(ClassMethods)\n  end\n  \n  module ClassMethods\n    def next_id\n      @id_counter ||= 0\n      @id_counter += 1\n    end\n    \n    def reset_id_counter!\n      @id_counter = 0\n    end\n  end\n  \n  def assign_id\n    @id ||= self.class.next_id\n  end\nend\n\nputs '✓ mixins.rb loaded successfully'"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "ruby",
        "filename": "models.rb",
        "save": true,
        "session_id": "ruby-blog",
        "code": "# Model classes for our Ruby blog application\nrequire_relative 'mixins'\n\n# Base model class\nclass BaseModel\n  include Timestampable\n  include Validatable\n  include Serializable\n  include Identifiable\n  \n  def initialize\n    @created_at = Time.now\n    @updated_at = Time.now\n    assign_id\n  end\nend\n\n# User model\nclass User < BaseModel\n  attr_accessor :username, :email, :role\n  attr_reader :id, :password_hash\n  \n  # Class method to track all users\n  @@all_users = []\n  \n  validate :username do |value|\n    'Username is required' if value.nil? || value.empty?\n  end\n  \n  validate :email do |value|\n    'Invalid email format' unless value =~ /\\A[\\w+\\-.]+@[a-z\\d\\-.]+\\.[a-z]+\\z/i\n  end\n  \n  def initialize(username:, email:, password:, role: :reader)\n    super()\n    @username = username\n    @email = email\n    @role = role\n    self.password = password\n    @@all_users << self\n  end\n  \n  def password=(new_password)\n    require 'digest'\n    @password_hash = Digest::SHA256.hexdigest(new_password)\n  end\n  \n  def authenticate(password)\n    require 'digest'\n    Digest::SHA256.hexdigest(password) == @password_hash\n  end\n  \n  def admin?\n    @role == :admin\n  end\n  \n  def author?\n    [:admin, :author].include?(@role)\n  end\n  \n  def self.all\n    @@all_users\n  end\n  \n  def self.find_by_username(username)\n    @@all_users.find { |user| user.username == username }\n  end\n  \n  def self.find(id)\n    @@all_users.find { |user| user.id == id }\n  end\nend\n\n# Post model\nclass Post < BaseModel\n  attr_accessor :title, :content, :published, :tags\n  attr_reader :id, :author\n  \n  @@all_posts = []\n  \n  validate :title do |value|\n    'Title is required' if value.nil? || value.empty?\n  end\n  \n  validate :content do |value|\n    if value.nil? || value.empty?\n      'Content is required'\n    elsif value.length < 10\n      'Content must be at least 10 characters'\n    end\n  end\n  \n  def initialize(title:, content:, author:, tags: [])\n    super()\n    @title = title\n    @content = content\n    @author = author\n    @published = false\n    @tags = tags\n    @@all_posts << self\n  end\n  \n  def publish!\n    @published = true\n    touch\n    self\n  end\n  \n  def unpublish!\n    @published = false\n    touch\n    self\n  end\n  \n  def published?\n    @published\n  end\n  \n  def word_count\n    @content.split(/\\s+/).size\n  end\n  \n  def reading_time\n    # Average reading speed: 200 words per minute\n    (word_count / 200.0).ceil\n  end\n  \n  def summary(length = 100)\n    return @content if @content.length <= length\n    @content[0...length].gsub(/\\s\\w+$/, '...') # Clean word break\n  end\n  \n  def add_tag(tag)\n    @tags << tag unless @tags.include?(tag)\n    @tags\n  end\n  \n  def self.all\n    @@all_posts\n  end\n  \n  def self.published\n    @@all_posts.select(&:published?)\n  end\n  \n  def self.by_author(author)\n    @@all_posts.select { |post| post.author == author }\n  end\n  \n  def self.with_tag(tag)\n    @@all_posts.select { |post| post.tags.include?(tag) }\n  end\nend\n\n# Comment model with nested structure support\nclass Comment < BaseModel\n  attr_accessor :content, :post, :author, :parent\n  attr_reader :id, :replies\n  \n  @@all_comments = []\n  \n  validate :content do |value|\n    'Comment cannot be empty' if value.nil? || value.empty?\n  end\n  \n  def initialize(content:, post:, author:, parent: nil)\n    super()\n    @content = content\n    @post = post\n    @author = author\n    @parent = parent\n    @replies = []\n    parent.add_reply(self) if parent\n    @@all_comments << self\n  end\n  \n  def reply(content:, author:)\n    Comment.new(content: content, post: @post, author: author, parent: self)\n  end\n  \n  def add_reply(comment)\n    @replies << comment\n  end\n  \n  def root?\n    @parent.nil?\n  end\n  \n  def depth\n    root? ? 0 : @parent.depth + 1\n  end\n  \n  def thread\n    root? ? [self] + all_replies : @parent.thread\n  end\n  \n  def all_replies\n    @replies + @replies.flat_map(&:all_replies)\n  end\n  \n  def self.all\n    @@all_comments\n  end\n  \n  def self.for_post(post)\n    @@all_comments.select { |comment| comment.post == post }\n  end\nend\n\nputs '✓ models.rb loaded successfully'"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "validate_code",
      "arguments": {
        "language": "ruby",
        "filename": "services.rb",
        "save": true,
        "session_id": "ruby-blog",
        "code": "# Service classes for our Ruby blog application\nrequire_relative 'models'\n\n# Blog service for managing posts and interactions\nclass BlogService\n  class PublishError < StandardError; end\n  class AuthorizationError < StandardError; end\n  \n  def initialize\n    @observers = []\n  end\n  \n  # Observer pattern for notifications\n  def attach(observer)\n    @observers << observer\n  end\n  \n  def notify(event, data)\n    @observers.each { |observer| observer.update(event, data) }\n  end\n  \n  # Create a new post with authorization check\n  def create_post(author:, title:, content:, tags: [])\n    raise AuthorizationError, \"User cannot create posts\" unless author.author?\n    \n    post = Post.new(\n      author: author,\n      title: title,\n      content: content,\n      tags: tags\n    )\n    \n    if post.valid?\n      notify(:post_created, post)\n      post\n    else\n      raise PublishError, \"Invalid post: #{post.errors}\"\n    end\n  end\n  \n  # Publish a post with validation\n  def publish_post(post, user)\n    raise AuthorizationError, \"Only authors can publish\" unless user.author?\n    raise AuthorizationError, \"Can only publish own posts\" unless post.author == user || user.admin?\n    raise PublishError, \"Post is invalid\" unless post.valid?\n    \n    post.publish!\n    notify(:post_published, post)\n    post\n  end\n  \n  # Add comment with threading support\n  def add_comment(post:, author:, content:, parent: nil)\n    comment = Comment.new(\n      post: post,\n      author: author,\n      content: content,\n      parent: parent\n    )\n    \n    if comment.valid?\n      notify(:comment_added, comment)\n      comment\n    else\n      raise \"Invalid comment: #{comment.errors}\"\n    end\n  end\n  \n  # Search posts using blocks\n  def search_posts(query = nil, &block)\n    posts = Post.published\n    \n    if block_given?\n      posts.select(&block)\n    elsif query\n      posts.select do |post|\n        post.title.downcase.include?(query.downcase) ||\n        post.content.downcase.include?(query.downcase) ||\n        post.tags.any? { |tag| tag.downcase.include?(query.downcase) }\n      end\n    else\n      posts\n    end\n  end\n  \n  # Get trending posts\n  def trending_posts(limit: 5)\n    Post.published\n        .sort_by { |post| -calculate_trend_score(post) }\n        .take(limit)\n  end\n  \n  private\n  \n  def calculate_trend_score(post)\n    age_hours = post.age_in_seconds / 3600.0\n    comments_count = Comment.for_post(post).size\n    \n    # Simple trending algorithm\n    (comments_count + 1) / (age_hours + 2) ** 1.5\n  end\nend\n\n# Analytics service for blog statistics\nclass AnalyticsService\n  def self.generate_report\n    {\n      users: user_stats,\n      posts: post_stats,\n      engagement: engagement_stats\n    }\n  end\n  \n  def self.user_stats\n    users = User.all\n    {\n      total: users.size,\n      by_role: users.group_by(&:role).transform_values(&:size),\n      most_active: most_active_authors(3)\n    }\n  end\n  \n  def self.post_stats\n    posts = Post.all\n    published = posts.select(&:published?)\n    \n    {\n      total: posts.size,\n      published: published.size,\n      draft: posts.size - published.size,\n      avg_word_count: published.empty? ? 0 : published.sum(&:word_count) / published.size,\n      popular_tags: popular_tags(5)\n    }\n  end\n  \n  def self.engagement_stats\n    comments = Comment.all\n    posts_with_comments = comments.map(&:post).uniq\n    \n    {\n      total_comments: comments.size,\n      posts_with_comments: posts_with_comments.size,\n      avg_comments_per_post: posts_with_comments.empty? ? 0 : comments.size.to_f / posts_with_comments.size,\n      comment_threads: comments.select(&:root?).size\n    }\n  end\n  \n  def self.most_active_authors(limit)\n    Post.all\n        .group_by(&:author)\n        .transform_values(&:size)\n        .sort_by { |_, count| -count }\n        .take(limit)\n        .map { |author, count| { username: author.username, posts: count } }\n  end\n  \n  def self.popular_tags(limit)\n    Post.all\n        .flat_map(&:tags)\n        .tally\n        .sort_by { |_, count| -count }\n        .take(limit)\n        .to_h\n  end\nend\n\n# Notification observer for blog events\nclass NotificationObserver\n  def initialize(name)\n    @name = name\n  end\n  \n  def update(event, data)\n    timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')\n    \n    case event\n    when :post_created\n      puts \"[#{timestamp}] #{@name}: New post '#{data.title}' by #{data.author.username}\"\n    when :post_published\n      puts \"[#{timestamp}] #{@name}: Post '#{data.title}' published!\"\n    when :comment_added\n      puts \"[#{timestamp}] #{@name}: New comment by #{data.author.username} on '#{data.post.title}'\"\n    end\n  end\nend\n\n# Feed generator using duck typing\nclass FeedGenerator\n  def self.generate(items, format: :summary)\n    items.map do |item|\n      if item.respond_to?(:title) && item.respond_to?(:summary)\n        # It's a post\n        format_post(item, format)\n      elsif item.respond_to?(:content) && item.respond_to?(:author)\n        # It's a comment\n        format_comment(item, format)\n      else\n        # Unknown type, use generic formatting\n        format_generic(item)\n      end\n    end\n  end\n  \n  def self.format_post(post, format)\n    case format\n    when :summary\n      {\n        type: 'post',\n        title: post.title,\n        summary: post.summary(150),\n        author: post.author.username,\n        reading_time: \"#{post.reading_time} min read\",\n        published: post.published?\n      }\n    when :full\n      post.to_hash\n    end\n  end\n  \n  def self.format_comment(comment, format)\n    {\n      type: 'comment',\n      content: comment.content[0..100],\n      author: comment.author.username,\n      post_title: comment.post.title,\n      depth: comment.depth\n    }\n  end\n  \n  def self.format_generic(item)\n    {\n      type: 'unknown',\n      data: item.respond_to?(:to_hash) ? item.to_hash : item.to_s\n    }\n  end\nend\n\nputs '✓ services.rb loaded successfully'"
      }
    }
  },
  {
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "execute_code",
      "arguments": {
        "language": "ruby",
        "filename": "main.rb",
        "save": true,
        "session_id": "ruby-blog",
        "code": "#!/usr/bin/env ruby\n# Main application demonstrating Ruby blog system\n\nputs '=== MULTI-FILE RUBY BLOG APPLICATION DEMO ==='\nputs\n\n# Load all required files\nbegin\n  require_relative 'mixins'\n  require_relative 'models'\n  require_relative 'services'\n  puts '✓ All modules loaded successfully'\nrescue LoadError => e\n  puts \"✗ Module loading failed: #{e.message}\"\n  puts 'Make sure all files were saved to the session'\n  exit 1\nend\n\nputs\nputs '=== CREATING USERS ==='\n\n# Create users with different roles\nadmin = User.new(\n  username: 'admin',\n  email: 'admin@blog.com',\n  password: 'secure123',\n  role: :admin\n)\nputs \"Created admin: #{admin.username} (#{admin.email})\"\n\nauthor1 = User.new(\n  username: 'alice_writer',\n  email: 'alice@blog.com',\n  password: 'password123',\n  role: :author\n)\nputs \"Created author: #{author1.username} (#{author1.email})\"\n\nauthor2 = User.new(\n  username: 'bob_blogger',\n  email: 'bob@blog.com',\n  password: 'secret456',\n  role: :author\n)\nputs \"Created author: #{author2.username} (#{author2.email})\"\n\nreader = User.new(\n  username: 'charlie_reader',\n  email: 'charlie@blog.com',\n  password: 'reading123',\n  role: :reader\n)\nputs \"Created reader: #{reader.username} (#{reader.email})\"\n\nputs\nputs '=== TESTING AUTHENTICATION ==='\n\nputs \"Alice authenticates with correct password: #{author1.authenticate('password123')}\"\nputs \"Alice authenticates with wrong password: #{author1.authenticate('wrong')}\"\n\nputs\nputs '=== CREATING BLOG SERVICE ==='\n\nblog = BlogService.new\n\n# Attach notification observers\nemail_notifier = NotificationObserver.new('EmailNotifier')\nslack_notifier = NotificationObserver.new('SlackNotifier')\n\nblog.attach(email_notifier)\nblog.attach(slack_notifier)\n\nputs 'Blog service created with email and Slack notifications'\n\nputs\nputs '=== CREATING POSTS ==='\n\n# Create posts using the service\nbegin\n  post1 = blog.create_post(\n    author: author1,\n    title: 'Getting Started with Ruby Metaprogramming',\n    content: 'Ruby metaprogramming is a powerful feature that allows you to write code that writes code. ' \\\n             'In this post, we will explore define_method, method_missing, and class_eval to create ' \\\n             'dynamic and flexible Ruby programs. Metaprogramming can seem magical at first, but ' \\\n             'understanding how it works will make you a better Ruby developer.',\n    tags: ['ruby', 'metaprogramming', 'advanced']\n  )\n  puts \"✓ Created post: '#{post1.title}'\"\n  \n  post2 = blog.create_post(\n    author: author2,\n    title: 'Building RESTful APIs with Ruby',\n    content: 'REST APIs are the backbone of modern web applications. In this tutorial, we will ' \\\n             'build a complete REST API using Ruby and Sinatra. We will cover routing, middleware, ' \\\n             'authentication, and best practices for API design. By the end, you will have a ' \\\n             'production-ready API that follows REST principles.',\n    tags: ['ruby', 'api', 'rest', 'sinatra']\n  )\n  puts \"✓ Created post: '#{post2.title}'\"\n  \n  post3 = blog.create_post(\n    author: author1,\n    title: 'Understanding Ruby Blocks, Procs, and Lambdas',\n    content: 'Blocks, procs, and lambdas are fundamental to Ruby programming. They allow you to ' \\\n             'pass chunks of code around and create powerful abstractions. This post will explain ' \\\n             'the differences between them, when to use each, and common patterns you will encounter ' \\\n             'in Ruby libraries and frameworks.',\n    tags: ['ruby', 'fundamentals', 'blocks']\n  )\n  puts \"✓ Created post: '#{post3.title}'\"\n  \n  # Try to create post as reader (should fail)\n  blog.create_post(\n    author: reader,\n    title: 'My Post',\n    content: 'This should fail',\n    tags: []\n  )\nrescue BlogService::AuthorizationError => e\n  puts \"✗ Authorization error: #{e.message}\"\nend\n\nputs\nputs '=== PUBLISHING POSTS ==='\n\n# Publish some posts\nblog.publish_post(post1, author1)\nblog.publish_post(post2, author2)\n\n# Admin can publish anyone's post\nblog.publish_post(post3, admin)\n\nputs\nputs '=== ADDING COMMENTS ==='\n\n# Add comments to posts\ncomment1 = blog.add_comment(\n  post: post1,\n  author: reader,\n  content: 'Great introduction to metaprogramming! Can you cover send() method next?'\n)\n\ncomment2 = blog.add_comment(\n  post: post1,\n  author: author1,\n  content: 'Thanks! I will definitely cover send() and public_send() in my next post.',\n  parent: comment1\n)\n\ncomment3 = blog.add_comment(\n  post: post2,\n  author: author1,\n  content: 'Nice tutorial! Have you considered using Grape for API development?'\n)\n\ncomment4 = blog.add_comment(\n  post: post2,\n  author: author2,\n  content: 'Grape is great too! I chose Sinatra for its simplicity in this tutorial.',\n  parent: comment3\n)\n\nputs\nputs '=== SEARCHING POSTS ==='\n\n# Search using query\nruby_posts = blog.search_posts('ruby')\nputs \"Posts containing 'ruby': #{ruby_posts.map(&:title)}\"\n\n# Search using block\nlong_posts = blog.search_posts { |post| post.word_count > 50 }\nputs \"Posts with >50 words: #{long_posts.map(&:title)}\"\n\nputs\nputs '=== TRENDING POSTS ==='\n\ntrending = blog.trending_posts(limit: 3)\nputs 'Top trending posts:'\ntrending.each_with_index do |post, i|\n  comments_count = Comment.for_post(post).size\n  puts \"  #{i + 1}. #{post.title} (#{comments_count} comments)\"\nend\n\nputs\nputs '=== ANALYTICS REPORT ==='\n\nreport = AnalyticsService.generate_report\nputs 'Blog Analytics:'\nputs \"  Users: #{report[:users][:total]} total\"\nputs \"  Roles: #{report[:users][:by_role]}\"\nputs \"  Posts: #{report[:posts][:published]} published, #{report[:posts][:draft]} drafts\"\nputs \"  Average word count: #{report[:posts][:avg_word_count]}\"\nputs \"  Popular tags: #{report[:posts][:popular_tags]}\"\nputs \"  Total comments: #{report[:engagement][:total_comments]}\"\nputs \"  Comment threads: #{report[:engagement][:comment_threads]}\"\n\nputs\nputs '=== GENERATING FEED ==='\n\n# Mix posts and comments in feed\nfeed_items = [post1, comment1, post2, comment3].shuffle\nfeed = FeedGenerator.generate(feed_items)\n\nputs 'Mixed content feed:'\nfeed.each do |item|\n  puts \"  [#{item[:type]}] #{item[:author]}: #{item[:title] || item[:content]}\"\nend\n\nputs\nputs '=== DEMONSTRATING RUBY FEATURES ==='\n\n# Exception handling\nbegin\n  invalid_user = User.new(username: '', email: 'invalid', password: '123')\n  puts \"User valid? #{invalid_user.valid?}\"\n  puts \"Validation errors: #{invalid_user.errors}\"\nrescue => e\n  puts \"Error: #{e.message}\"\nend\n\n# Duck typing - anything that responds to certain methods\nclass FakePost\n  def title; 'Fake Post'; end\n  def summary(_); 'This is a fake post...'; end\n  def author; OpenStruct.new(username: 'faker'); end\n  def reading_time; 1; end\n  def published?; true; end\nend\n\nfake_feed = FeedGenerator.generate([FakePost.new])\nputs \"\\nDuck typing example - FakePost in feed: #{fake_feed.first}\"\n\n# Blocks and iterators\nputs \"\\nUsing blocks for filtering:\"\nPost.all.select { |p| p.published? }.each do |post|\n  puts \"  - #{post.title} (#{post.reading_time} min read)\"\nend\n\n# Method chaining\nputs \"\\nMethod chaining example:\"\ntagged_posts = Post.all\n                  .select(&:published?)\n                  .select { |p| p.tags.include?('ruby') }\n                  .sort_by(&:created_at)\n                  .reverse\n                  .take(2)\nputs \"Latest Ruby posts: #{tagged_posts.map(&:title)}\"\n\nputs\nputs '=== SERIALIZATION EXAMPLE ==='\n\nputs \"Post as JSON:\"\nputs post1.to_json\n\nputs\nputs '=== APPLICATION SUMMARY ==='\nputs \"Total users: #{User.all.size}\"\nputs \"Total posts: #{Post.all.size} (#{Post.published.size} published)\"\nputs \"Total comments: #{Comment.all.size}\"\nputs \"Comment threads: #{Comment.all.select(&:root?).size}\"\n\nputs\nputs '✅ Multi-file Ruby blog application demo completed!'\nputs\nputs '🔄 All Ruby files persist within this container session'\nputs '🗑️  Files will be cleaned up when container restarts'\nputs '🔒 Host system remains completely isolated'\nputs\nputs '📚 Ruby features demonstrated:'\nputs '   - Modules and mixins (Timestampable, Validatable, etc.)'\nputs '   - Class inheritance (BaseModel hierarchy)'\nputs '   - attr_accessor/reader/writer'\nputs '   - Duck typing (FeedGenerator)'\nputs '   - Blocks, procs, and iterators'\nputs '   - Exception handling'\nputs '   - Metaprogramming (dynamic validations)'\nputs '   - Observer pattern'\nputs '   - Method chaining'"
      }
    }
  }
]